CCS PCH C Compiler, Version 5.081, 13314               08-may.-25 01:49

               Filename:   C:\Users\artga\MPLABXProjects\protolink\Galio-ProtoLink.X\build\default\production\src\main.lst

               ROM used:   6420 bytes (5%)
                           Largest free fragment is 65536
               RAM used:   439 (12%) at main() level
                           485 (14%) worst case
               Stack used: 3 locations (0 in main + 3 for interrupts)
               Stack size: 31

*
00000:  GOTO   1714
*
00008:  MOVWF  04
0000A:  MOVFF  FD8,05
0000E:  MOVFF  FE0,06
00012:  MOVLB  0
00014:  MOVFF  FE9,0C
00018:  MOVFF  FEA,07
0001C:  MOVFF  FE1,08
00020:  MOVFF  FE2,09
00024:  MOVFF  FD9,0A
00028:  MOVFF  FDA,0B
0002C:  MOVFF  FF3,12
00030:  MOVFF  FF4,13
00034:  MOVFF  FFA,14
00038:  MOVFF  FF5,15
0003C:  MOVFF  FF6,16
00040:  MOVFF  FF7,17
00044:  MOVFF  FF8,18
00048:  MOVFF  FFB,19
0004C:  MOVFF  00,0E
00050:  MOVFF  01,0F
00054:  MOVFF  02,10
00058:  MOVFF  03,11
0005C:  MOVLB  E
0005E:  BTFSS  x2D.1
00060:  GOTO   006A
00064:  BTFSC  x37.1
00066:  GOTO   0434
0006A:  BTFSS  x2D.5
0006C:  GOTO   0076
00070:  BTFSC  x37.5
00072:  GOTO   03A8
00076:  BTFSS  x2E.0
00078:  GOTO   0082
0007C:  BTFSC  x38.0
0007E:  GOTO   0300
00082:  MOVFF  0E,00
00086:  MOVFF  0F,01
0008A:  MOVFF  10,02
0008E:  MOVFF  11,03
00092:  MOVFF  0C,FE9
00096:  MOVFF  07,FEA
0009A:  BSF    07.7
0009C:  MOVFF  08,FE1
000A0:  MOVFF  09,FE2
000A4:  MOVFF  0A,FD9
000A8:  MOVFF  0B,FDA
000AC:  MOVFF  12,FF3
000B0:  MOVFF  13,FF4
000B4:  MOVFF  14,FFA
000B8:  MOVFF  15,FF5
000BC:  MOVFF  16,FF6
000C0:  MOVFF  17,FF7
000C4:  MOVFF  18,FF8
000C8:  MOVFF  19,FFB
000CC:  MOVF   04,W
000CE:  MOVFF  06,FE0
000D2:  MOVFF  05,FD8
000D6:  RETFIE 0
.................... /*  
....................  * File:   main.c 
....................  * Author: Arturo Gasca 
....................  * 
....................  * Created on 4 de febrero de 2025, 04:11 PM 
....................  */ 
....................  
.................... #include <18F67K40.h> 
.................... //////////// Standard Header file for the PIC18F67K40 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
*
00304:  MOVLB  E
00306:  BCF    x38.0
00308:  MOVLB  0
0030A:  GOTO   0082
.................... #device PIC18F67K40 
*
000D8:  CLRF   FF7
000DA:  ADDLW  EC
000DC:  MOVWF  FF6
000DE:  MOVLW  00
000E0:  ADDWFC FF7,F
000E2:  MOVLW  00
000E4:  MOVWF  FF8
000E6:  TBLRD*+
000E8:  MOVF   FF5,W
000EA:  RETURN 0
000EC:  DATA 00,C1
000EE:  DATA 81,40
000F0:  DATA 01,C0
000F2:  DATA 80,41
000F4:  DATA 01,C0
000F6:  DATA 80,41
000F8:  DATA 00,C1
000FA:  DATA 81,40
000FC:  DATA 01,C0
000FE:  DATA 80,41
00100:  DATA 00,C1
00102:  DATA 81,40
00104:  DATA 00,C1
00106:  DATA 81,40
00108:  DATA 01,C0
0010A:  DATA 80,41
0010C:  DATA 01,C0
0010E:  DATA 80,41
00110:  DATA 00,C1
00112:  DATA 81,40
00114:  DATA 00,C1
00116:  DATA 81,40
00118:  DATA 01,C0
0011A:  DATA 80,41
0011C:  DATA 00,C1
0011E:  DATA 81,40
00120:  DATA 01,C0
00122:  DATA 80,41
00124:  DATA 01,C0
00126:  DATA 80,41
00128:  DATA 00,C1
0012A:  DATA 81,40
0012C:  DATA 01,C0
0012E:  DATA 80,41
00130:  DATA 00,C1
00132:  DATA 81,40
00134:  DATA 00,C1
00136:  DATA 81,40
00138:  DATA 01,C0
0013A:  DATA 80,41
0013C:  DATA 00,C1
0013E:  DATA 81,40
00140:  DATA 01,C0
00142:  DATA 80,41
00144:  DATA 01,C0
00146:  DATA 80,41
00148:  DATA 00,C1
0014A:  DATA 81,40
0014C:  DATA 00,C1
0014E:  DATA 81,40
00150:  DATA 01,C0
00152:  DATA 80,41
00154:  DATA 01,C0
00156:  DATA 80,41
00158:  DATA 00,C1
0015A:  DATA 81,40
0015C:  DATA 01,C0
0015E:  DATA 80,41
00160:  DATA 00,C1
00162:  DATA 81,40
00164:  DATA 00,C1
00166:  DATA 81,40
00168:  DATA 01,C0
0016A:  DATA 80,41
0016C:  DATA 01,C0
0016E:  DATA 80,41
00170:  DATA 00,C1
00172:  DATA 81,40
00174:  DATA 00,C1
00176:  DATA 81,40
00178:  DATA 01,C0
0017A:  DATA 80,41
0017C:  DATA 00,C1
0017E:  DATA 81,40
00180:  DATA 01,C0
00182:  DATA 80,41
00184:  DATA 01,C0
00186:  DATA 80,41
00188:  DATA 00,C1
0018A:  DATA 81,40
0018C:  DATA 00,C1
0018E:  DATA 81,40
00190:  DATA 01,C0
00192:  DATA 80,41
00194:  DATA 01,C0
00196:  DATA 80,41
00198:  DATA 00,C1
0019A:  DATA 81,40
0019C:  DATA 01,C0
0019E:  DATA 80,41
001A0:  DATA 00,C1
001A2:  DATA 81,40
001A4:  DATA 00,C1
001A6:  DATA 81,40
001A8:  DATA 01,C0
001AA:  DATA 80,41
001AC:  DATA 00,C1
001AE:  DATA 81,40
001B0:  DATA 01,C0
001B2:  DATA 80,41
001B4:  DATA 01,C0
001B6:  DATA 80,41
001B8:  DATA 00,C1
001BA:  DATA 81,40
001BC:  DATA 01,C0
001BE:  DATA 80,41
001C0:  DATA 00,C1
001C2:  DATA 81,40
001C4:  DATA 00,C1
001C6:  DATA 81,40
001C8:  DATA 01,C0
001CA:  DATA 80,41
001CC:  DATA 01,C0
001CE:  DATA 80,41
001D0:  DATA 00,C1
001D2:  DATA 81,40
001D4:  DATA 00,C1
001D6:  DATA 81,40
001D8:  DATA 01,C0
001DA:  DATA 80,41
001DC:  DATA 00,C1
001DE:  DATA 81,40
001E0:  DATA 01,C0
001E2:  DATA 80,41
001E4:  DATA 01,C0
001E6:  DATA 80,41
001E8:  DATA 00,C1
001EA:  DATA 81,40
001EC:  CLRF   FF7
001EE:  ADDLW  00
001F0:  MOVWF  FF6
001F2:  MOVLW  02
001F4:  ADDWFC FF7,F
001F6:  MOVLW  00
001F8:  MOVWF  FF8
001FA:  TBLRD*+
001FC:  MOVF   FF5,W
001FE:  RETURN 0
00200:  DATA 00,C0
00202:  DATA C1,01
00204:  DATA C3,03
00206:  DATA 02,C2
00208:  DATA C6,06
0020A:  DATA 07,C7
0020C:  DATA 05,C5
0020E:  DATA C4,04
00210:  DATA CC,0C
00212:  DATA 0D,CD
00214:  DATA 0F,CF
00216:  DATA CE,0E
00218:  DATA 0A,CA
0021A:  DATA CB,0B
0021C:  DATA C9,09
0021E:  DATA 08,C8
00220:  DATA D8,18
00222:  DATA 19,D9
00224:  DATA 1B,DB
00226:  DATA DA,1A
00228:  DATA 1E,DE
0022A:  DATA DF,1F
0022C:  DATA DD,1D
0022E:  DATA 1C,DC
00230:  DATA 14,D4
00232:  DATA D5,15
00234:  DATA D7,17
00236:  DATA 16,D6
00238:  DATA D2,12
0023A:  DATA 13,D3
0023C:  DATA 11,D1
0023E:  DATA D0,10
00240:  DATA F0,30
00242:  DATA 31,F1
00244:  DATA 33,F3
00246:  DATA F2,32
00248:  DATA 36,F6
0024A:  DATA F7,37
0024C:  DATA F5,35
0024E:  DATA 34,F4
00250:  DATA 3C,FC
00252:  DATA FD,3D
00254:  DATA FF,3F
00256:  DATA 3E,FE
00258:  DATA FA,3A
0025A:  DATA 3B,FB
0025C:  DATA 39,F9
0025E:  DATA F8,38
00260:  DATA 28,E8
00262:  DATA E9,29
00264:  DATA EB,2B
00266:  DATA 2A,EA
00268:  DATA EE,2E
0026A:  DATA 2F,EF
0026C:  DATA 2D,ED
0026E:  DATA EC,2C
00270:  DATA E4,24
00272:  DATA 25,E5
00274:  DATA 27,E7
00276:  DATA E6,26
00278:  DATA 22,E2
0027A:  DATA E3,23
0027C:  DATA E1,21
0027E:  DATA 20,E0
00280:  DATA A0,60
00282:  DATA 61,A1
00284:  DATA 63,A3
00286:  DATA A2,62
00288:  DATA 66,A6
0028A:  DATA A7,67
0028C:  DATA A5,65
0028E:  DATA 64,A4
00290:  DATA 6C,AC
00292:  DATA AD,6D
00294:  DATA AF,6F
00296:  DATA 6E,AE
00298:  DATA AA,6A
0029A:  DATA 6B,AB
0029C:  DATA 69,A9
0029E:  DATA A8,68
002A0:  DATA 78,B8
002A2:  DATA B9,79
002A4:  DATA BB,7B
002A6:  DATA 7A,BA
002A8:  DATA BE,7E
002AA:  DATA 7F,BF
002AC:  DATA 7D,BD
002AE:  DATA BC,7C
002B0:  DATA B4,74
002B2:  DATA 75,B5
002B4:  DATA 77,B7
002B6:  DATA B6,76
002B8:  DATA 72,B2
002BA:  DATA B3,73
002BC:  DATA B1,71
002BE:  DATA 70,B0
002C0:  DATA 50,90
002C2:  DATA 91,51
002C4:  DATA 93,53
002C6:  DATA 52,92
002C8:  DATA 96,56
002CA:  DATA 57,97
002CC:  DATA 55,95
002CE:  DATA 94,54
002D0:  DATA 9C,5C
002D2:  DATA 5D,9D
002D4:  DATA 5F,9F
002D6:  DATA 9E,5E
002D8:  DATA 5A,9A
002DA:  DATA 9B,5B
002DC:  DATA 99,59
002DE:  DATA 58,98
002E0:  DATA 88,48
002E2:  DATA 49,89
002E4:  DATA 4B,8B
002E6:  DATA 8A,4A
002E8:  DATA 4E,8E
002EA:  DATA 8F,4F
002EC:  DATA 8D,4D
002EE:  DATA 4C,8C
002F0:  DATA 44,84
002F2:  DATA 85,45
002F4:  DATA 87,47
002F6:  DATA 46,86
002F8:  DATA 82,42
002FA:  DATA 43,83
002FC:  DATA 41,81
002FE:  DATA 80,40
00300:  MOVLB  0
00302:  INCF   x6E,F
*
0049C:  DATA 31,20
0049E:  DATA 45,6E
004A0:  DATA 20,52
004A2:  DATA 53,54
004A4:  DATA 20,0D
004A6:  DATA 0A,00
004A8:  DATA 30,20
004AA:  DATA 45,6E
004AC:  DATA 20,52
004AE:  DATA 53,54
004B0:  DATA 0D,0A
004B2:  DATA 00,00
004B4:  DATA 5B,44
004B6:  DATA 45,42
004B8:  DATA 55,47
004BA:  DATA 5D,44
004BC:  DATA 61,74
004BE:  DATA 61,20
004C0:  DATA 73,65
004C2:  DATA 6E,74
004C4:  DATA 3A,20
004C6:  DATA 5B,00
004C8:  DATA 5B,44
004CA:  DATA 45,56
004CC:  DATA 49,43
004CE:  DATA 45,5D
004D0:  DATA 20,44
004D2:  DATA 61,74
004D4:  DATA 61,20
004D6:  DATA 61,76
004D8:  DATA 61,69
004DA:  DATA 6C,61
004DC:  DATA 62,6C
004DE:  DATA 65,0D
004E0:  DATA 0A,00
004E2:  DATA 5B,44
004E4:  DATA 45,56
004E6:  DATA 49,43
004E8:  DATA 45,5D
004EA:  DATA 20,54
004EC:  DATA 69,6D
004EE:  DATA 65,6F
004F0:  DATA 75,74
004F2:  DATA 20,53
004F4:  DATA 65,72
004F6:  DATA 69,61
004F8:  DATA 6C,0D
004FA:  DATA 0A,00
*
00524:  TSTFSZ 01
00526:  BRA    052E
00528:  TSTFSZ 02
0052A:  BRA    0530
0052C:  BRA    053C
0052E:  INCF   02,F
00530:  MOVFF  00,FEE
00534:  DECFSZ 01,F
00536:  BRA    0530
00538:  DECFSZ 02,F
0053A:  BRA    0530
0053C:  GOTO   054E (RETURN)
*
005F8:  MOVLB  1
005FA:  MOVF   xCC,W
005FC:  BTFSC  FD8.2
005FE:  BRA    06E2
00600:  MOVWF  00
00602:  MOVF   xD0,W
00604:  BTFSC  FD8.2
00606:  BRA    06E2
00608:  ADDWF  00,F
0060A:  BNC   0614
0060C:  MOVLW  81
0060E:  ADDWF  00,F
00610:  BC    06E2
00612:  BRA    061C
00614:  MOVLW  7F
00616:  SUBWF  00,F
00618:  BNC   06E2
0061A:  BZ    06E2
0061C:  MOVFF  1CD,1D4
00620:  MOVF   xD1,W
00622:  XORWF  xD4,F
00624:  BSF    xCD.7
00626:  BSF    xD1.7
00628:  MOVF   xCF,W
0062A:  MULWF  xD3
0062C:  MOVFF  FF4,1D6
00630:  MOVF   xCE,W
00632:  MULWF  xD2
00634:  MOVFF  FF4,03
00638:  MOVFF  FF3,1D5
0063C:  MULWF  xD3
0063E:  MOVF   FF3,W
00640:  ADDWF  xD6,F
00642:  MOVF   FF4,W
00644:  ADDWFC xD5,F
00646:  MOVLW  00
00648:  ADDWFC 03,F
0064A:  MOVF   xCF,W
0064C:  MULWF  xD2
0064E:  MOVF   FF3,W
00650:  ADDWF  xD6,F
00652:  MOVF   FF4,W
00654:  ADDWFC xD5,F
00656:  MOVLW  00
00658:  CLRF   02
0065A:  ADDWFC 03,F
0065C:  ADDWFC 02,F
0065E:  MOVF   xCD,W
00660:  MULWF  xD3
00662:  MOVF   FF3,W
00664:  ADDWF  xD5,F
00666:  MOVF   FF4,W
00668:  ADDWFC 03,F
0066A:  MOVLW  00
0066C:  ADDWFC 02,F
0066E:  MOVF   xCD,W
00670:  MULWF  xD2
00672:  MOVF   FF3,W
00674:  ADDWF  03,F
00676:  MOVF   FF4,W
00678:  ADDWFC 02,F
0067A:  MOVLW  00
0067C:  CLRF   01
0067E:  ADDWFC 01,F
00680:  MOVF   xCF,W
00682:  MULWF  xD1
00684:  MOVF   FF3,W
00686:  ADDWF  xD5,F
00688:  MOVF   FF4,W
0068A:  ADDWFC 03,F
0068C:  MOVLW  00
0068E:  ADDWFC 02,F
00690:  ADDWFC 01,F
00692:  MOVF   xCE,W
00694:  MULWF  xD1
00696:  MOVF   FF3,W
00698:  ADDWF  03,F
0069A:  MOVF   FF4,W
0069C:  ADDWFC 02,F
0069E:  MOVLW  00
006A0:  ADDWFC 01,F
006A2:  MOVF   xCD,W
006A4:  MULWF  xD1
006A6:  MOVF   FF3,W
006A8:  ADDWF  02,F
006AA:  MOVF   FF4,W
006AC:  ADDWFC 01,F
006AE:  INCF   00,F
006B0:  BTFSC  01.7
006B2:  BRA    06BE
006B4:  RLCF   xD5,F
006B6:  RLCF   03,F
006B8:  RLCF   02,F
006BA:  RLCF   01,F
006BC:  DECF   00,F
006BE:  MOVLW  00
006C0:  BTFSS  xD5.7
006C2:  BRA    06D8
006C4:  INCF   03,F
006C6:  ADDWFC 02,F
006C8:  ADDWFC 01,F
006CA:  MOVF   01,W
006CC:  BNZ   06D8
006CE:  MOVF   02,W
006D0:  BNZ   06D8
006D2:  MOVF   03,W
006D4:  BNZ   06D8
006D6:  INCF   00,F
006D8:  BTFSC  xD4.7
006DA:  BSF    01.7
006DC:  BTFSS  xD4.7
006DE:  BCF    01.7
006E0:  BRA    06EA
006E2:  CLRF   00
006E4:  CLRF   01
006E6:  CLRF   02
006E8:  CLRF   03
006EA:  MOVLB  0
006EC:  RETURN 0
006EE:  MOVLW  8E
006F0:  MOVWF  00
006F2:  MOVFF  1D1,01
006F6:  MOVFF  1D0,02
006FA:  CLRF   03
006FC:  MOVF   01,F
006FE:  BNZ   0712
00700:  MOVFF  02,01
00704:  CLRF   02
00706:  MOVLW  08
00708:  SUBWF  00,F
0070A:  MOVF   01,F
0070C:  BNZ   0712
0070E:  CLRF   00
00710:  BRA    0722
00712:  BCF    FD8.0
00714:  BTFSC  01.7
00716:  BRA    0720
00718:  RLCF   02,F
0071A:  RLCF   01,F
0071C:  DECF   00,F
0071E:  BRA    0712
00720:  BCF    01.7
00722:  RETURN 0
00724:  MOVLB  1
00726:  MOVF   xD0,W
00728:  BTFSC  FD8.2
0072A:  BRA    0876
0072C:  MOVWF  xDC
0072E:  MOVF   xD4,W
00730:  BTFSC  FD8.2
00732:  BRA    0876
00734:  SUBWF  xDC,F
00736:  BNC   0742
00738:  MOVLW  7F
0073A:  ADDWF  xDC,F
0073C:  BTFSC  FD8.0
0073E:  BRA    0876
00740:  BRA    074E
00742:  MOVLW  81
00744:  SUBWF  xDC,F
00746:  BTFSS  FD8.0
00748:  BRA    0876
0074A:  BTFSC  FD8.2
0074C:  BRA    0876
0074E:  MOVFF  1DC,00
00752:  CLRF   01
00754:  CLRF   02
00756:  CLRF   03
00758:  CLRF   xDB
0075A:  MOVFF  1D1,1DA
0075E:  BSF    xDA.7
00760:  MOVFF  1D2,1D9
00764:  MOVFF  1D3,1D8
00768:  MOVLW  19
0076A:  MOVWF  xDC
0076C:  MOVF   xD7,W
0076E:  SUBWF  xD8,F
00770:  BC    078C
00772:  MOVLW  01
00774:  SUBWF  xD9,F
00776:  BC    078C
00778:  SUBWF  xDA,F
0077A:  BC    078C
0077C:  SUBWF  xDB,F
0077E:  BC    078C
00780:  INCF   xDB,F
00782:  INCF   xDA,F
00784:  INCF   xD9,F
00786:  MOVF   xD7,W
00788:  ADDWF  xD8,F
0078A:  BRA    07DC
0078C:  MOVF   xD6,W
0078E:  SUBWF  xD9,F
00790:  BC    07B6
00792:  MOVLW  01
00794:  SUBWF  xDA,F
00796:  BC    07B6
00798:  SUBWF  xDB,F
0079A:  BC    07B6
0079C:  INCF   xDB,F
0079E:  INCF   xDA,F
007A0:  MOVF   xD6,W
007A2:  ADDWF  xD9,F
007A4:  MOVF   xD7,W
007A6:  ADDWF  xD8,F
007A8:  BNC   07DC
007AA:  INCF   xD9,F
007AC:  BNZ   07DC
007AE:  INCF   xDA,F
007B0:  BNZ   07DC
007B2:  INCF   xDB,F
007B4:  BRA    07DC
007B6:  MOVF   xD5,W
007B8:  IORLW  80
007BA:  SUBWF  xDA,F
007BC:  BC    07DA
007BE:  MOVLW  01
007C0:  SUBWF  xDB,F
007C2:  BC    07DA
007C4:  INCF   xDB,F
007C6:  MOVF   xD5,W
007C8:  IORLW  80
007CA:  ADDWF  xDA,F
007CC:  MOVF   xD6,W
007CE:  ADDWF  xD9,F
007D0:  BNC   07A4
007D2:  INCF   xDA,F
007D4:  BNZ   07A4
007D6:  INCF   xDB,F
007D8:  BRA    07A4
007DA:  BSF    03.0
007DC:  DECFSZ xDC,F
007DE:  BRA    07E2
007E0:  BRA    07F8
007E2:  BCF    FD8.0
007E4:  RLCF   xD8,F
007E6:  RLCF   xD9,F
007E8:  RLCF   xDA,F
007EA:  RLCF   xDB,F
007EC:  BCF    FD8.0
007EE:  RLCF   03,F
007F0:  RLCF   02,F
007F2:  RLCF   01,F
007F4:  RLCF   xDD,F
007F6:  BRA    076C
007F8:  BTFSS  xDD.0
007FA:  BRA    0808
007FC:  BCF    FD8.0
007FE:  RRCF   01,F
00800:  RRCF   02,F
00802:  RRCF   03,F
00804:  RRCF   xDD,F
00806:  BRA    080C
00808:  DECF   00,F
0080A:  BZ    0876
0080C:  BTFSC  xDD.7
0080E:  BRA    084C
00810:  BCF    FD8.0
00812:  RLCF   xD8,F
00814:  RLCF   xD9,F
00816:  RLCF   xDA,F
00818:  RLCF   xDB,F
0081A:  MOVF   xD7,W
0081C:  SUBWF  xD8,F
0081E:  BC    082E
00820:  MOVLW  01
00822:  SUBWF  xD9,F
00824:  BC    082E
00826:  SUBWF  xDA,F
00828:  BC    082E
0082A:  SUBWF  xDB,F
0082C:  BNC   0862
0082E:  MOVF   xD6,W
00830:  SUBWF  xD9,F
00832:  BC    083E
00834:  MOVLW  01
00836:  SUBWF  xDA,F
00838:  BC    083E
0083A:  SUBWF  xDB,F
0083C:  BNC   0862
0083E:  MOVF   xD5,W
00840:  IORLW  80
00842:  SUBWF  xDA,F
00844:  BC    084C
00846:  MOVLW  01
00848:  SUBWF  xDB,F
0084A:  BNC   0862
0084C:  INCF   03,F
0084E:  BNZ   0862
00850:  INCF   02,F
00852:  BNZ   0862
00854:  INCF   01,F
00856:  BNZ   0862
00858:  INCF   00,F
0085A:  BZ    0876
0085C:  RRCF   01,F
0085E:  RRCF   02,F
00860:  RRCF   03,F
00862:  MOVFF  1D1,1DC
00866:  MOVF   xD5,W
00868:  XORWF  xDC,F
0086A:  BTFSS  xDC.7
0086C:  BRA    0872
0086E:  BSF    01.7
00870:  BRA    087E
00872:  BCF    01.7
00874:  BRA    087E
00876:  CLRF   00
00878:  CLRF   01
0087A:  CLRF   02
0087C:  CLRF   03
0087E:  MOVLB  0
00880:  GOTO   0BFE (RETURN)
00884:  MOVLW  80
00886:  BTFSS  FD8.1
00888:  BRA    088E
0088A:  MOVLB  1
0088C:  XORWF  xD5,F
0088E:  MOVLB  1
00890:  CLRF   xDA
00892:  CLRF   xDB
00894:  MOVFF  1D1,1D9
00898:  MOVF   xD5,W
0089A:  XORWF  xD9,F
0089C:  MOVF   xD0,W
0089E:  BTFSC  FD8.2
008A0:  BRA    0A60
008A2:  MOVWF  xD8
008A4:  MOVWF  00
008A6:  MOVF   xD4,W
008A8:  BTFSC  FD8.2
008AA:  BRA    0A72
008AC:  SUBWF  xD8,F
008AE:  BTFSC  FD8.2
008B0:  BRA    09B8
008B2:  BNC   0930
008B4:  MOVFF  1D5,1DE
008B8:  BSF    xDE.7
008BA:  MOVFF  1D6,1DD
008BE:  MOVFF  1D7,1DC
008C2:  CLRF   xDB
008C4:  BCF    FD8.0
008C6:  RRCF   xDE,F
008C8:  RRCF   xDD,F
008CA:  RRCF   xDC,F
008CC:  RRCF   xDB,F
008CE:  DECFSZ xD8,F
008D0:  BRA    08C2
008D2:  BTFSS  xD9.7
008D4:  BRA    08DC
008D6:  BSF    xDA.0
008D8:  BRA    0A9A
008DA:  BCF    xDA.0
008DC:  BCF    xD8.0
008DE:  BSF    xDA.4
008E0:  MOVLW  01
008E2:  MOVWF  FEA
008E4:  MOVLW  D3
008E6:  MOVWF  FE9
008E8:  BRA    0AC0
008EA:  BCF    xDA.4
008EC:  BTFSC  xD9.7
008EE:  BRA    0904
008F0:  BTFSS  xD8.0
008F2:  BRA    091A
008F4:  RRCF   xDE,F
008F6:  RRCF   xDD,F
008F8:  RRCF   xDC,F
008FA:  RRCF   xDB,F
008FC:  INCF   00,F
008FE:  BTFSC  FD8.2
00900:  BRA    0A90
00902:  BRA    091A
00904:  BTFSC  xDE.7
00906:  BRA    0920
00908:  BCF    FD8.0
0090A:  RLCF   xDB,F
0090C:  RLCF   xDC,F
0090E:  RLCF   xDD,F
00910:  RLCF   xDE,F
00912:  DECF   00,F
00914:  BTFSC  FD8.2
00916:  BRA    0A90
00918:  BRA    0904
0091A:  BSF    xDA.6
0091C:  BRA    09F8
0091E:  BCF    xDA.6
00920:  MOVFF  1D1,1D9
00924:  BTFSS  xD1.7
00926:  BRA    092C
00928:  BSF    xDE.7
0092A:  BRA    0A82
0092C:  BCF    xDE.7
0092E:  BRA    0A82
00930:  MOVFF  1D4,1D8
00934:  MOVFF  1D4,00
00938:  MOVF   xD0,W
0093A:  SUBWF  xD8,F
0093C:  MOVFF  1D1,1DE
00940:  BSF    xDE.7
00942:  MOVFF  1D2,1DD
00946:  MOVFF  1D3,1DC
0094A:  CLRF   xDB
0094C:  BCF    FD8.0
0094E:  RRCF   xDE,F
00950:  RRCF   xDD,F
00952:  RRCF   xDC,F
00954:  RRCF   xDB,F
00956:  DECFSZ xD8,F
00958:  BRA    094A
0095A:  BTFSS  xD9.7
0095C:  BRA    0964
0095E:  BSF    xDA.1
00960:  BRA    0A9A
00962:  BCF    xDA.1
00964:  BCF    xD8.0
00966:  BSF    xDA.5
00968:  MOVLW  01
0096A:  MOVWF  FEA
0096C:  MOVLW  D7
0096E:  MOVWF  FE9
00970:  BRA    0AC0
00972:  BCF    xDA.5
00974:  BTFSC  xD9.7
00976:  BRA    098C
00978:  BTFSS  xD8.0
0097A:  BRA    09A2
0097C:  RRCF   xDE,F
0097E:  RRCF   xDD,F
00980:  RRCF   xDC,F
00982:  RRCF   xDB,F
00984:  INCF   00,F
00986:  BTFSC  FD8.2
00988:  BRA    0A90
0098A:  BRA    09A2
0098C:  BTFSC  xDE.7
0098E:  BRA    09A8
00990:  BCF    FD8.0
00992:  RLCF   xDB,F
00994:  RLCF   xDC,F
00996:  RLCF   xDD,F
00998:  RLCF   xDE,F
0099A:  DECF   00,F
0099C:  BTFSC  FD8.2
0099E:  BRA    0A90
009A0:  BRA    098C
009A2:  BSF    xDA.7
009A4:  BRA    09F8
009A6:  BCF    xDA.7
009A8:  MOVFF  1D5,1D9
009AC:  BTFSS  xD5.7
009AE:  BRA    09B4
009B0:  BSF    xDE.7
009B2:  BRA    0A82
009B4:  BCF    xDE.7
009B6:  BRA    0A82
009B8:  MOVFF  1D5,1DE
009BC:  BSF    xDE.7
009BE:  MOVFF  1D6,1DD
009C2:  MOVFF  1D7,1DC
009C6:  BTFSS  xD9.7
009C8:  BRA    09D2
009CA:  BCF    xDE.7
009CC:  BSF    xDA.2
009CE:  BRA    0A9A
009D0:  BCF    xDA.2
009D2:  CLRF   xDB
009D4:  BCF    xD8.0
009D6:  MOVLW  01
009D8:  MOVWF  FEA
009DA:  MOVLW  D3
009DC:  MOVWF  FE9
009DE:  BRA    0AC0
009E0:  BTFSC  xD9.7
009E2:  BRA    0A1C
009E4:  MOVFF  1D1,1D9
009E8:  BTFSS  xD8.0
009EA:  BRA    09F8
009EC:  RRCF   xDE,F
009EE:  RRCF   xDD,F
009F0:  RRCF   xDC,F
009F2:  RRCF   xDB,F
009F4:  INCF   00,F
009F6:  BZ    0A90
009F8:  BTFSS  xDB.7
009FA:  BRA    0A12
009FC:  INCF   xDC,F
009FE:  BNZ   0A12
00A00:  INCF   xDD,F
00A02:  BNZ   0A12
00A04:  INCF   xDE,F
00A06:  BNZ   0A12
00A08:  RRCF   xDE,F
00A0A:  RRCF   xDD,F
00A0C:  RRCF   xDC,F
00A0E:  INCF   00,F
00A10:  BZ    0A90
00A12:  BTFSC  xDA.6
00A14:  BRA    091E
00A16:  BTFSC  xDA.7
00A18:  BRA    09A6
00A1A:  BRA    0A54
00A1C:  MOVLW  80
00A1E:  XORWF  xDE,F
00A20:  BTFSS  xDE.7
00A22:  BRA    0A2C
00A24:  BRA    0A9A
00A26:  MOVFF  1D5,1D9
00A2A:  BRA    0A40
00A2C:  MOVFF  1D1,1D9
00A30:  MOVF   xDE,F
00A32:  BNZ   0A40
00A34:  MOVF   xDD,F
00A36:  BNZ   0A40
00A38:  MOVF   xDC,F
00A3A:  BNZ   0A40
00A3C:  CLRF   00
00A3E:  BRA    0A82
00A40:  BTFSC  xDE.7
00A42:  BRA    0A54
00A44:  BCF    FD8.0
00A46:  RLCF   xDB,F
00A48:  RLCF   xDC,F
00A4A:  RLCF   xDD,F
00A4C:  RLCF   xDE,F
00A4E:  DECFSZ 00,F
00A50:  BRA    0A40
00A52:  BRA    0A90
00A54:  BTFSS  xD9.7
00A56:  BRA    0A5C
00A58:  BSF    xDE.7
00A5A:  BRA    0A82
00A5C:  BCF    xDE.7
00A5E:  BRA    0A82
00A60:  MOVFF  1D4,00
00A64:  MOVFF  1D5,1DE
00A68:  MOVFF  1D6,1DD
00A6C:  MOVFF  1D7,1DC
00A70:  BRA    0A82
00A72:  MOVFF  1D0,00
00A76:  MOVFF  1D1,1DE
00A7A:  MOVFF  1D2,1DD
00A7E:  MOVFF  1D3,1DC
00A82:  MOVFF  1DE,01
00A86:  MOVFF  1DD,02
00A8A:  MOVFF  1DC,03
00A8E:  BRA    0AF8
00A90:  CLRF   00
00A92:  CLRF   01
00A94:  CLRF   02
00A96:  CLRF   03
00A98:  BRA    0AF8
00A9A:  CLRF   xDB
00A9C:  COMF   xDC,F
00A9E:  COMF   xDD,F
00AA0:  COMF   xDE,F
00AA2:  COMF   xDB,F
00AA4:  INCF   xDB,F
00AA6:  BNZ   0AB2
00AA8:  INCF   xDC,F
00AAA:  BNZ   0AB2
00AAC:  INCF   xDD,F
00AAE:  BNZ   0AB2
00AB0:  INCF   xDE,F
00AB2:  BTFSC  xDA.0
00AB4:  BRA    08DA
00AB6:  BTFSC  xDA.1
00AB8:  BRA    0962
00ABA:  BTFSC  xDA.2
00ABC:  BRA    09D0
00ABE:  BRA    0A26
00AC0:  MOVF   FEF,W
00AC2:  ADDWF  xDC,F
00AC4:  BNC   0AD0
00AC6:  INCF   xDD,F
00AC8:  BNZ   0AD0
00ACA:  INCF   xDE,F
00ACC:  BTFSC  FD8.2
00ACE:  BSF    xD8.0
00AD0:  MOVF   FED,F
00AD2:  MOVF   FEF,W
00AD4:  ADDWF  xDD,F
00AD6:  BNC   0ADE
00AD8:  INCF   xDE,F
00ADA:  BTFSC  FD8.2
00ADC:  BSF    xD8.0
00ADE:  MOVF   FED,F
00AE0:  MOVF   FEF,W
00AE2:  BTFSC  FEF.7
00AE4:  BRA    0AE8
00AE6:  XORLW  80
00AE8:  ADDWF  xDE,F
00AEA:  BTFSC  FD8.0
00AEC:  BSF    xD8.0
00AEE:  BTFSC  xDA.4
00AF0:  BRA    08EA
00AF2:  BTFSC  xDA.5
00AF4:  BRA    0972
00AF6:  BRA    09E0
00AF8:  MOVLB  0
00AFA:  RETURN 0
....................  
.................... #list 
....................  
.................... #device ADC = 10 
.................... //#use fast_io(G) 
.................... #include "tunacore.h" 
.................... /*  
....................  * File:   tunacore.h 
....................  * Author: Arturo Gasca 
....................  * 
....................  * Modified on 04 de Agosto de 2021 
....................  */ 
....................  
.................... #ifndef TUNACORE_H 
.................... #define	TUNACORE_H 
....................  
.................... /*USER BUTTON AND LEDS*/ 
.................... #define USER        PIN_B2  //Interruption 2 
.................... #define LED1        PIN_F0 
.................... #define LED2        PIN_F1 
....................  
.................... /*USB SERIAL*/ 
.................... #define TX_1        PIN_C6 
.................... #define RX_1        PIN_C7 
....................  
.................... /*HEADER RS485*/ 
.................... #define TX_5        PIN_E2 
.................... #define RX_5        PIN_E3 
.................... #define TX_ENABLE   PIN_E6  //Internal Auxiliar 
.................... #define RX_ENABLE   PIN_E7  //Internal Auxiliar 
....................  
.................... /*HEADER UART*/ 
.................... #define TX_4        PIN_C0 
.................... #define RX_4        PIN_C1 
....................  
.................... /*HEADER RS232*/ 
.................... #define TX_2        PIN_G1 
.................... #define RX_2        PIN_G2 
....................  
.................... /*HEADER ANALOG*/ 
.................... #define ANALOG_1    PIN_A0 
.................... #define ANALOG_2    PIN_A1 
....................  
.................... /*HEADER PWM*/ 
.................... #define PWM_1       PIN_E5 
.................... #define PWM_2       PIN_E4 
....................  
.................... /*EEPROM Write Protect*/ 
.................... #define EE_WP       PIN_G7 
....................  
.................... /*RTC AUX*/ 
.................... #define RTC_INT     PIN_B3  //Interruption 3 
....................  
.................... /*ACCESORY EXPANSION HEADER*/ 
.................... #define EXP_SDA     PIN_C4  //I2C General Board 
.................... #define EXP_SCL     PIN_C3  //I2C General Board 
.................... #define EXP_GPIO1   PIN_F2 
.................... #define EXP_GPIO2   PIN_F3 
.................... #define EXP_INT0    PIN_B0 
.................... #define EXP_INT1    PIN_B1 
....................  
.................... /*TELEMETRY COMMUNICATION HEADER*/ 
.................... #define COM_TX      PIN_E0 //TX UART3 
.................... #define COM_RX      PIN_E1 //RX UART3 
.................... #define COM_MISO    PIN_D4 
.................... #define COM_MOSI    PIN_D5 
.................... #define COM_SCLK    PIN_D6 
.................... #define COM_AUX     PIN_D7 
.................... #define COM_RST     PIN_G0 
....................  
....................  
....................  
.................... //UART1 
.................... #pin_select U1TX=TX_1 
.................... #pin_select U1RX=RX_1 
....................  
.................... //UART2 
.................... #pin_select U2TX=TX_2 
.................... #pin_select U2RX=RX_2 
....................  
.................... //UART3 
.................... #pin_select U3TX=COM_TX 
.................... #pin_select U3RX=COM_RX 
....................  
.................... //UART4 
.................... #pin_select U4TX=TX_4 
.................... #pin_select U4RX=RX_4 
....................  
.................... //UART5 
.................... #pin_select U5TX=TX_5 
.................... #pin_select U5RX=RX_5 
....................  
.................... //I2C1 
.................... #pin_select SCL1IN=EXP_SCL 
.................... #pin_select SDA1IN=EXP_SDA 
....................  
....................  
....................  
.................... #endif	/* TUNACORE_H */ 
....................  
....................  
....................  
.................... #define DEVICE_DEBUG            TRUE 
.................... #define DEVICE_SERIAL_SOURCE    UART_INT_RDA3 
.................... #define DEVICE_SERIAL_BAUD      9600 
.................... #define DEVICE_RST_PIN          COM_RST 
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
*
0056A:  MOVFF  1BE,1C4
0056E:  MOVFF  1BD,1C3
00572:  MOVLB  1
00574:  MOVF   xC1,F
00576:  BNZ   057C
00578:  MOVF   xC2,F
0057A:  BZ    05C6
0057C:  MOVFF  1C0,03
00580:  MOVFF  1BF,FE9
00584:  MOVFF  03,FEA
00588:  MOVF   FEF,F
0058A:  BZ    05C6
....................      *s++ = *s2++; 
0058C:  MOVFF  1C4,1C6
00590:  MOVF   xC3,W
00592:  INCF   xC3,F
00594:  BTFSC  FD8.2
00596:  INCF   xC4,F
00598:  MOVWF  xC5
0059A:  MOVFF  1C0,03
0059E:  MOVF   xBF,W
005A0:  INCF   xBF,F
005A2:  BTFSC  FD8.2
005A4:  INCF   xC0,F
005A6:  MOVWF  FE9
005A8:  MOVFF  03,FEA
005AC:  MOVFF  FEF,1C7
005B0:  MOVFF  1C6,FEA
005B4:  MOVFF  1C5,FE9
005B8:  MOVFF  1C7,FEF
005BC:  MOVF   xC1,W
005BE:  BTFSC  FD8.2
005C0:  DECF   xC2,F
005C2:  DECF   xC1,F
005C4:  BRA    0574
....................   for (; n > 0; n--) 
005C6:  MOVF   xC1,F
005C8:  BNZ   05CE
005CA:  MOVF   xC2,F
005CC:  BZ    05EC
....................      *s++ = '\0'; 
005CE:  MOVFF  1C4,03
005D2:  MOVF   xC3,W
005D4:  INCF   xC3,F
005D6:  BTFSC  FD8.2
005D8:  INCF   xC4,F
005DA:  MOVWF  FE9
005DC:  MOVFF  03,FEA
005E0:  CLRF   FEF
005E2:  MOVF   xC1,W
005E4:  BTFSC  FD8.2
005E6:  DECF   xC2,F
005E8:  DECF   xC1,F
005EA:  BRA    05C6
....................  
....................   return(s1); 
005EC:  MOVFF  1BD,01
005F0:  MOVFF  1BE,02
005F4:  MOVLB  0
005F6:  RETURN 0
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlib.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2007 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... #ifndef _STDLIB 
.................... #define _STDLIB 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Definitions and types 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #ifndef RAND_MAX 
.................... #define RAND_MAX  32767    // The value of which is the maximum value 
....................                            // ... returned by the rand function 
.................... #endif 
....................  
....................  
.................... #IF (sizeof(int16*)>1) 
.................... #DEFINE LONG_POINTERS 1 
.................... #ELSE  
.................... #DEFINE LONG_POINTERS 0 
.................... #ENDIF 
....................  
.................... typedef struct { 
....................    signed int quot; 
....................    signed int rem; 
.................... } div_t; 
....................  
.................... typedef struct { 
....................    signed long quot; 
....................    signed long rem; 
.................... } ldiv_t; 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // String conversion functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Standard template: signed int  atoi(char * s) 
....................  * converts the initial portion of the string s to a signed int 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed int atoi(char *s); 
....................  
.................... /* Syntax: signed int32  atoi32(char * s) 
....................    converts the initial portion of the string s to a signed int32 
....................    returns the converted value if any, 0 otherwise*/ 
.................... #if (sizeof(long)==4) 
....................  #define atoi32(s) atol(s) 
.................... #else  
....................  signed int32 atoi32(char *s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
.................... /* Syntax: signed int48  atoi48(char * s) 
....................    converts the initial portion of the string s to a signed int48 
....................    returns the converted value if any, 0 otherwise*/ 
....................     
.................... signed int48 atoi48(char *s); 
....................  
.................... /* Syntax: signed int64  atoi64(char * s) 
....................    converts the initial portion of the string s to a signed int64 
....................    returns the converted value if any, 0 otherwise*/ 
.................... signed int64 atoi64(char *s); 
.................... #endif 
....................  
.................... /* Syntax: char *  itoa(signed int32 num, int8 base, char * s) 
....................    converts the signed int32 to a string and 
....................    returns the converted value if any, 0 otherwise*/ 
.................... char * itoa(signed int32 num, unsigned int base, char * s); 
....................  
.................... /* Standard template: signed int16  atol(char * s) 
....................  * converts the initial portion of the string s to a signed int16 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... signed long atol(char *s); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base  to a signed long. 
....................  * Returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... signed long strtol(char *s,char *endptr, signed int base); 
....................  
.................... /* Standard template: int16 strtoul(char * s,char *endptr,signed int base) 
....................  * converts the initial portion of the string s, represented as an 
....................  * integral value of radix base to a unsigned long. 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null 
....................  */ 
.................... unsigned long strtoul(char *s,char *endptr, signed int base); 
....................  
.................... /* Standart template: float strtof(char * s,char *endptr) 
....................                       float48 strtof48(char *s,char *endptr); 
....................                       float64 strtod(char *s,char *endptr); 
....................  * converts the initial portion of the string s to a float32, float48 or float64, 
....................  * returns the converted value if any, 0 otherwise 
....................  * the final string is returned in the endptr, if endptr is not null                    
.................... */ 
.................... float strtof(char *s,char **endptr); 
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s,char **endptr); 
.................... float64 strtod(char *s,char **endptr); 
.................... #else 
.................... //provided for compatibility 
.................... #define strtof48(s, e) strtof(s, e) 
.................... #define strtod(s, e) strtof(s, e) 
.................... #endif 
....................  
.................... /* Standard template: float32 atof(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof(s)   strtof(s, (char*)0) 
....................  
.................... #if defined(__PCD__) 
.................... // The following functions only work on the 24 bit compiler 
.................... // for the 30F, 33F, 24F and 24H parts 
....................  
.................... /* Standard template: float48 atof48(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof48(s) strtof48(s, 0) 
....................  
.................... /* Standard template: float64 atof64(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  */ 
.................... #define atof64(s) strtod(s, 0) 
.................... #endif 
....................  
.................... /* Standard template: float32 atoe(char * s) 
....................  * converts the initial portion of the string s to a float. 
....................  * returns the converted value if any, 0 otherwise 
....................  * also handles E format numbers 
....................  */ 
.................... #if !defined(__PCD__) 
.................... float atoe(char * s); 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s); 
.................... #endif 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Pseudo-random sequence generation functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The rand function computes a sequence of pseudo-random integers in 
....................  * the range 0 to RAND_MAX 
....................  * 
....................  * Parameters: 
....................  *       (none) 
....................  * 
....................  * Returns: 
....................  *       The pseudo-random integer 
....................  */ 
.................... unsigned int16 rand(void); 
....................  
.................... /* The srand function uses the argument as a seed for a new sequence of 
....................  * pseudo-random numbers to be returned by subsequent calls to rand. 
....................  * 
....................  * Parameters: 
....................  *       [in] seed: The seed value to start from. You might need to pass 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  * 
....................  * Remarks 
....................  *          The srand function sets the starting point for generating 
....................  *       a series of pseudorandom integers. To reinitialize the 
....................  *       generator, use 1 as the seed argument. Any other value for 
....................  *       seed sets the generator to a random starting point. rand 
....................  *       retrieves the pseudorandom numbers that are generated. 
....................  *       Calling rand before any call to srand generates the same 
....................  *       sequence as calling srand with seed passed as 1. 
....................  *          Usually, you need to pass a time here from outer source 
....................  *       so that the numbers will be different every time you run. 
....................  */ 
.................... void srand(unsigned int32 seed); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Memory management functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Comming soon 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Communication with the environment 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* The function returns 0 always 
....................  */ 
.................... signed int8 system(char *string); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities 
.................... //--------------------------------------------------------------------------- 
....................  
.................... /* Performs a binary search of a sorted array.. 
....................  * 
....................  * Parameters: 
....................  *       [in] key: Object to search for 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       bsearch returns a pointer to an occurrence of key in the array pointed 
....................  *       to by base. If key is not found, the function returns NULL. If the 
....................  *       array is not in order or contains duplicate records with identical keys, 
....................  *       the result is unpredictable. 
....................  */ 
.................... //void *bsearch(const void *key, const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... /* Performs the shell-metzner sort (not the quick sort algorithm). The contents 
....................  * of the array are sorted into ascending order according to a comparison 
....................  * function pointed to by compar. 
....................  * 
....................  * Parameters: 
....................  *       [in] base: Pointer to base of search data 
....................  *       [in] num: Number of elements 
....................  *       [in] width: Width of elements 
....................  *       [in] compare: Function that compares two elements 
....................  * 
....................  * Returns: 
....................  *       (none) 
....................  */ 
.................... //void *qsort(const void *base, size_t num, size_t width, 
.................... //              int (*compare)(const void *, const void *)); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Integer arithmetic functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #define labs abs 
....................  
.................... div_t div(signed int numer, signed int denom); 
.................... ldiv_t ldiv(signed long numer, signed long denom); 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte character functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Multibyte string functions 
.................... //--------------------------------------------------------------------------- 
....................  
.................... // Not supported 
....................  
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Internal implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... #include <ctype.h> 
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... div_t div(signed int numer, signed int denom) 
.................... { 
....................    div_t val; 
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... ldiv_t ldiv(signed long numer, signed long denom) 
.................... { 
....................    ldiv_t val; 
....................  
....................    val.quot = numer / denom; 
....................    val.rem = numer - (denom * val.quot); 
....................    return (val); 
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float32 atoe(char * s) 
.................... { 
....................    float32 pow10 = 1.0; 
....................    float32 result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float32 exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if !defined(__PCD__) 
.................... float atoe(char * s) 
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    unsigned int8 sign = 0; 
....................    unsigned int8 expsign = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................    unsigned int8 i; 
....................    float exp = 1.0; 
....................    unsigned int8 expcnt = 0; 
....................  
....................    c = s[ptr++]; 
....................  
....................    if ((c>='0' && c<='9') || c=='+' || c=='-' || c=='.' || c=='E' || c=='e') { 
....................       if(c == '-') { 
....................          sign = 1; 
....................          c = s[ptr++]; 
....................       } 
....................       if(c == '+') 
....................          c = s[ptr++]; 
....................  
....................       while((c >= '0' && c <= '9')) { 
....................          result = 10*result + c - '0'; 
....................          c = s[ptr++]; 
....................       } 
....................  
....................       if (c == '.') { 
....................          c = s[ptr++]; 
....................          while((c >= '0' && c <= '9')) { 
....................              pow10 = pow10*10; 
....................              result += (c - '0')/pow10; 
....................              c = s[ptr++]; 
....................          } 
....................       } 
....................  
....................       // Handling the exponent 
....................       if (c=='e' || c=='E') { 
....................          c = s[ptr++]; 
....................  
....................          if(c == '-') { 
....................             expsign = 1; 
....................             c = s[ptr++]; 
....................          } 
....................          if(c == '+') 
....................             c = s[ptr++]; 
....................  
....................          while((c >= '0' && c <= '9')) { 
....................             expcnt = 10*expcnt + c - '0'; 
....................             c = s[ptr++]; 
....................          } 
....................  
....................          for(i=0;i<expcnt;i++) 
....................             exp*=10; 
....................  
....................          if(expsign==1) 
....................             result/=exp; 
....................          else 
....................             result*=exp; 
....................       } 
....................    } 
....................  
....................    if (sign == 1) 
....................       result = -1*result; 
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... signed int atoi(char *s) 
.................... { 
....................    signed int result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    // Omit all preceeding alpha characters 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................  
....................       // Check for hexa number 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c<='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++]; 
....................             c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (sign == 1 && base == 10) 
....................        result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed long atol(char *s) 
.................... { 
....................    signed long result; 
....................    unsigned int sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') 
....................          { 
....................             result = 10*result + (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ( (c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... /* A fast routine to multiply by 10 
....................  */ 
.................... signed int32 mult_with10(int32 num) 
.................... { 
....................    return ( (num << 1) + (num << 3) ); 
.................... } 
....................  
.................... #if sizeof(long)==2 
.................... signed int32 atoi32(char *s) 
.................... { 
....................    signed int32 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... #if defined(__PCD__) 
....................  
.................... signed int48 atoi48(char *s) 
.................... { 
....................    signed int48 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
....................  
.................... signed int64 atoi64(char *s) 
.................... { 
....................    signed int64 result; 
....................    int8 sign, base, index; 
....................    char c; 
....................  
....................    index = 0; 
....................    sign = 0; 
....................    base = 10; 
....................    result = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................    c = s[index++]; 
....................  
....................    // increase index if either positive or negative sign is detected 
....................    if (c == '-') 
....................    { 
....................       sign = 1;         // Set the sign to negative 
....................       c = s[index++]; 
....................    } 
....................    else if (c == '+') 
....................    { 
....................       c = s[index++]; 
....................    } 
....................  
....................    if (c >= '0' && c <= '9') 
....................    { 
....................       if (c == '0' && (s[index] == 'x' || s[index] == 'X')) 
....................       { 
....................          base = 16; 
....................          index++; 
....................          c = s[index++]; 
....................       } 
....................  
....................       // The number is a decimal number 
....................       if (base == 10) 
....................       { 
....................          while (c >= '0' && c <= '9') { 
....................             result = (result << 1) + (result << 3);  // result *= 10; 
....................             result += (c - '0'); 
....................             c = s[index++]; 
....................          } 
....................       } 
....................       else if (base == 16)    // The number is a hexa number 
....................       { 
....................          c = toupper(c); 
....................          while ((c >= '0' && c <= '9') || (c >= 'A' && c <='F')) 
....................          { 
....................             if (c >= '0' && c <= '9') 
....................                result = (result << 4) + (c - '0'); 
....................             else 
....................                result = (result << 4) + (c - 'A' + 10); 
....................  
....................             c = s[index++];c = toupper(c); 
....................          } 
....................       } 
....................    } 
....................  
....................    if (base == 10 && sign == 1) 
....................       result = -result; 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... char * itoa(signed int32 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int32 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #if defined(__PCD__) 
....................  
.................... char * itoa(signed int48 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int48 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................  
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1; 
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................  
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... char * itoa(signed int64 num, unsigned int base, char * s) 
.................... { 
....................      unsigned int64 temp=1; 
....................      unsigned int8 i,sign=0,cnt=0; 
....................      char c; 
....................       
....................      if(num<0) { 
....................          sign=1;        // Check for negative number 
....................          num*=-1;         
....................      } 
....................  
....................      while(temp>0) { 
....................          temp=(num/base); 
....................          s[cnt]=(num%base)+'0';    // Conversion 
....................  
....................          if(s[cnt]>0x39) 
....................             s[cnt]+=0x7; 
....................              
....................          cnt++; 
....................          num=temp; 
....................      } 
....................  
....................      if(sign==1) { 
....................          s[cnt]=0x2D;      // Negative sign 
....................          cnt++; 
....................      } 
....................  
....................      for(i = 0;i<(int8)(cnt/2);i++) { 
....................  
....................          c=s[i]; 
....................          s[i]=s[cnt-i-1];        // Reverse the number 
....................          s[cnt-i-1]=c; 
....................      } 
....................      s[cnt]='\0';     // End the string 
....................      return s; 
.................... } 
....................  
.................... #endif 
....................  
.................... float strtof(char *s, char **endptr) 
*
00AFC:  MOVLB  1
00AFE:  CLRF   xC4
00B00:  CLRF   xC3
00B02:  CLRF   xC2
00B04:  MOVLW  7F
00B06:  MOVWF  xC1
00B08:  CLRF   xC8
00B0A:  CLRF   xC7
00B0C:  CLRF   xC6
00B0E:  CLRF   xC5
00B10:  BSF    xC9.0
00B12:  BCF    xC9.1
00B14:  BCF    xC9.2
00B16:  CLRF   xCB
.................... { 
....................    float pow10 = 1.0; 
....................    float result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
00B18:  MOVF   xBD,W
00B1A:  IORWF  xBE,W
00B1C:  BNZ   0B28
....................       return 0; 
00B1E:  CLRF   00
00B20:  CLRF   01
00B22:  CLRF   02
00B24:  CLRF   03
00B26:  BRA    0D4A
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
00B28:  MOVF   xCB,W
00B2A:  INCF   xCB,F
00B2C:  ADDWF  xBD,W
00B2E:  MOVWF  FE9
00B30:  MOVLW  00
00B32:  ADDWFC xBE,W
00B34:  MOVWF  FEA
00B36:  MOVFF  FEF,1CA
00B3A:  MOVF   xCA,F
00B3C:  BTFSC  FD8.2
00B3E:  BRA    0CC8
....................    { 
....................       if (skip && !isspace(c)) 
00B40:  BTFSS  xC9.0
00B42:  BRA    0B62
00B44:  MOVF   xCA,W
00B46:  SUBLW  20
00B48:  BZ    0B62
....................       { 
....................          skip = 0; 
00B4A:  BCF    xC9.0
....................          if (c == '+') 
00B4C:  MOVF   xCA,W
00B4E:  SUBLW  2B
00B50:  BNZ   0B58
....................          { 
....................             sign = 0; 
00B52:  BCF    xC9.1
....................             continue; 
00B54:  BRA    0CB0
....................          }             
00B56:  BRA    0B62
....................          else if (c == '-') 
00B58:  MOVF   xCA,W
00B5A:  SUBLW  2D
00B5C:  BNZ   0B62
....................          { 
....................             sign = 1; 
00B5E:  BSF    xC9.1
....................             continue; 
00B60:  BRA    0CB0
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
00B62:  BTFSC  xC9.0
00B64:  BRA    0B74
00B66:  MOVF   xCA,W
00B68:  SUBLW  2E
00B6A:  BNZ   0B74
00B6C:  BTFSC  xC9.2
00B6E:  BRA    0B74
....................          point = 1; 
00B70:  BSF    xC9.2
00B72:  BRA    0CB0
....................       else if (!skip && isdigit(c)) 
00B74:  BTFSC  xC9.0
00B76:  BRA    0CAA
00B78:  MOVF   xCA,W
00B7A:  SUBLW  2F
00B7C:  BTFSC  FD8.0
00B7E:  BRA    0CAA
00B80:  MOVF   xCA,W
00B82:  SUBLW  39
00B84:  BTFSS  FD8.0
00B86:  BRA    0CAA
....................       { 
....................          c -= '0'; 
00B88:  MOVLW  30
00B8A:  SUBWF  xCA,F
....................          if (point) 
00B8C:  BTFSS  xC9.2
00B8E:  BRA    0C36
....................          { 
....................             pow10 = pow10 * 10.0; 
00B90:  MOVFF  1C4,1CF
00B94:  MOVFF  1C3,1CE
00B98:  MOVFF  1C2,1CD
00B9C:  MOVFF  1C1,1CC
00BA0:  CLRF   xD3
00BA2:  CLRF   xD2
00BA4:  MOVLW  20
00BA6:  MOVWF  xD1
00BA8:  MOVLW  82
00BAA:  MOVWF  xD0
00BAC:  MOVLB  0
00BAE:  RCALL  05F8
00BB0:  MOVFF  03,1C4
00BB4:  MOVFF  02,1C3
00BB8:  MOVFF  01,1C2
00BBC:  MOVFF  00,1C1
....................             result += (float)c / pow10;    
00BC0:  MOVLB  1
00BC2:  CLRF   xD1
00BC4:  MOVFF  1CA,1D0
00BC8:  MOVLB  0
00BCA:  RCALL  06EE
00BCC:  MOVFF  03,1CF
00BD0:  MOVFF  02,1CE
00BD4:  MOVFF  01,1CD
00BD8:  MOVFF  00,1CC
00BDC:  MOVFF  03,1D3
00BE0:  MOVFF  02,1D2
00BE4:  MOVFF  01,1D1
00BE8:  MOVFF  00,1D0
00BEC:  MOVFF  1C4,1D7
00BF0:  MOVFF  1C3,1D6
00BF4:  MOVFF  1C2,1D5
00BF8:  MOVFF  1C1,1D4
00BFC:  BRA    0724
00BFE:  BCF    FD8.1
00C00:  MOVFF  1C8,1D3
00C04:  MOVFF  1C7,1D2
00C08:  MOVFF  1C6,1D1
00C0C:  MOVFF  1C5,1D0
00C10:  MOVFF  03,1D7
00C14:  MOVFF  02,1D6
00C18:  MOVFF  01,1D5
00C1C:  MOVFF  00,1D4
00C20:  RCALL  0884
00C22:  MOVFF  03,1C8
00C26:  MOVFF  02,1C7
00C2A:  MOVFF  01,1C6
00C2E:  MOVFF  00,1C5
....................          } 
00C32:  BRA    0CA6
00C34:  MOVLB  1
....................          else 
....................          { 
....................             result = 10.0 * result + (float)c; 
00C36:  CLRF   xCF
00C38:  CLRF   xCE
00C3A:  MOVLW  20
00C3C:  MOVWF  xCD
00C3E:  MOVLW  82
00C40:  MOVWF  xCC
00C42:  MOVFF  1C8,1D3
00C46:  MOVFF  1C7,1D2
00C4A:  MOVFF  1C6,1D1
00C4E:  MOVFF  1C5,1D0
00C52:  MOVLB  0
00C54:  RCALL  05F8
00C56:  MOVFF  03,1CF
00C5A:  MOVFF  02,1CE
00C5E:  MOVFF  01,1CD
00C62:  MOVFF  00,1CC
00C66:  MOVLB  1
00C68:  CLRF   xD1
00C6A:  MOVFF  1CA,1D0
00C6E:  MOVLB  0
00C70:  RCALL  06EE
00C72:  BCF    FD8.1
00C74:  MOVFF  1CF,1D3
00C78:  MOVFF  1CE,1D2
00C7C:  MOVFF  1CD,1D1
00C80:  MOVFF  1CC,1D0
00C84:  MOVFF  03,1D7
00C88:  MOVFF  02,1D6
00C8C:  MOVFF  01,1D5
00C90:  MOVFF  00,1D4
00C94:  RCALL  0884
00C96:  MOVFF  03,1C8
00C9A:  MOVFF  02,1C7
00C9E:  MOVFF  01,1C6
00CA2:  MOVFF  00,1C5
....................          } 
....................       } 
00CA6:  BRA    0CB2
00CA8:  MOVLB  1
....................       else if (!skip) 
00CAA:  BTFSC  xC9.0
00CAC:  BRA    0CB0
....................          break; 
00CAE:  BRA    0CC8
00CB0:  MOVLB  0
00CB2:  MOVLB  1
00CB4:  MOVF   xCB,W
00CB6:  INCF   xCB,F
00CB8:  ADDWF  xBD,W
00CBA:  MOVWF  FE9
00CBC:  MOVLW  00
00CBE:  ADDWFC xBE,W
00CC0:  MOVWF  FEA
00CC2:  MOVFF  FEF,1CA
00CC6:  BRA    0B3A
....................    } 
....................  
....................    if (sign) 
00CC8:  BTFSS  xC9.1
00CCA:  BRA    0CFE
....................       result = -1*result; 
00CCC:  CLRF   xCF
00CCE:  CLRF   xCE
00CD0:  MOVLW  80
00CD2:  MOVWF  xCD
00CD4:  MOVLW  7F
00CD6:  MOVWF  xCC
00CD8:  MOVFF  1C8,1D3
00CDC:  MOVFF  1C7,1D2
00CE0:  MOVFF  1C6,1D1
00CE4:  MOVFF  1C5,1D0
00CE8:  MOVLB  0
00CEA:  RCALL  05F8
00CEC:  MOVFF  03,1C8
00CF0:  MOVFF  02,1C7
00CF4:  MOVFF  01,1C6
00CF8:  MOVFF  00,1C5
00CFC:  MOVLB  1
....................        
....................    if(endptr) 
00CFE:  MOVF   xBF,W
00D00:  IORWF  xC0,W
00D02:  BZ    0D3A
....................    { 
....................       if (ptr) { 
00D04:  MOVF   xCB,F
00D06:  BZ    0D24
....................          ptr--; 
00D08:  DECF   xCB,F
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
00D0A:  MOVFF  1C0,03
00D0E:  MOVFF  1BF,FE9
00D12:  MOVFF  03,FEA
00D16:  MOVF   xCB,W
00D18:  ADDWF  xBD,W
00D1A:  MOVWF  FEF
00D1C:  MOVLW  00
00D1E:  ADDWFC xBE,W
00D20:  MOVWF  FEC
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
00D22:  BRA    0D3A
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
00D24:  MOVFF  1C0,03
00D28:  MOVFF  1BF,FE9
00D2C:  MOVFF  03,FEA
00D30:  MOVFF  1BE,FEC
00D34:  MOVF   FED,F
00D36:  MOVFF  1BD,FEF
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
00D3A:  MOVFF  1C5,00
00D3E:  MOVFF  1C6,01
00D42:  MOVFF  1C7,02
00D46:  MOVFF  1C8,03
00D4A:  MOVLB  0
00D4C:  RETURN 0
.................... } 
....................  
.................... #if defined(__PCD__) 
.................... float48 strtof48(char *s, char **endptr) 
.................... { 
....................    float48 pow10 = 1.0; 
....................    float48 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float48)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float48)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
....................  
.................... float64 strtod(char *s, char **endptr) 
.................... { 
....................    float64 pow10 = 1.0; 
....................    float64 result = 0.0; 
....................    int1 skip = 1, sign = 0, point = 0; 
....................    char c; 
....................    unsigned int8 ptr = 0; 
....................  
....................    if (!s) 
....................       return 0; 
....................  
....................    for(c=s[ptr++]; c!=0; c=s[ptr++]) 
....................    { 
....................       if (skip && !isspace(c)) 
....................       { 
....................          skip = 0; 
....................          if (c == '+') 
....................          { 
....................             sign = 0; 
....................             continue; 
....................          }             
....................          else if (c == '-') 
....................          { 
....................             sign = 1; 
....................             continue; 
....................          } 
....................       } 
....................       if (!skip && (c == '.') && !point) 
....................          point = 1; 
....................       else if (!skip && isdigit(c)) 
....................       { 
....................          c -= '0'; 
....................          if (point) 
....................          { 
....................             pow10 = pow10 * 10.0; 
....................             result += (float64)c / pow10;    
....................          } 
....................          else 
....................          { 
....................             result = 10.0 * result + (float64)c; 
....................          } 
....................       } 
....................       else if (!skip) 
....................          break; 
....................    } 
....................  
....................    if (sign) 
....................       result = -1*result; 
....................        
....................    if(endptr) 
....................    { 
....................       if (ptr) { 
....................          ptr--; 
....................        #IF LONG_POINTERS  
....................          *((int16 *)endptr)= s+ptr;  
....................        #ELSE 
....................          *((char *)endptr)=s+ptr; 
....................        #ENDIF 
....................       } 
....................       else 
....................       { 
....................       #IF LONG_POINTERS 
....................       *((int16 *)endptr)= s;  
....................       #ELSE 
....................       *((char *)endptr)=s; 
....................       #ENDIF 
....................       } 
....................    } 
....................  
....................    return(result); 
.................... } 
.................... #endif 
....................  
.................... unsigned long strtoul(char *s, char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    unsigned long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if(sign=='-' || base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtoulGO; 
....................  
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(; sd!=0; ) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtoulGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................          } 
....................    return 0; 
....................    } 
....................    if (endptr) 
....................    { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................          #ELSE 
....................          *((char *)endptr)=sc;  
....................          #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
....................  
.................... signed long strtol(char *s,char *endptr, signed int base) 
.................... { 
....................    char *sc,*s1,*sd; 
....................    signed long x=0; 
....................    char sign; 
....................    char digits[]="0123456789abcdefghijklmnopqstuvwxyz"; 
....................    for(sc=s;isspace(*sc);++sc); 
....................    sign=*sc=='-'||*sc=='+'?*sc++:'+'; 
....................    if (base <0 || base ==1|| base >36) // invalid base 
....................    goto StrtolGO; 
....................    else if (base) 
....................    { 
....................       if(base==16 && *sc =='0'&&(sc[1]=='x' || sc[1]=='X')) 
....................          sc+=2; 
....................       if(base==8 && *sc =='0') 
....................          sc+=1; 
....................       if(base==2 && *sc =='0'&&sc[1]=='b') 
....................          sc+=2; 
....................  
....................    } 
....................    else if(*sc!='0') // base is 0, find base 
....................       base=10; 
....................    else if (sc[1]=='x' || sc[1]=='X') 
....................       base =16,sc+=2; 
....................    else if(sc[1]=='b') 
....................       base=2,sc+=2; 
....................    else 
....................       base=8; 
....................    for (s1=sc;*sc=='0';++sc);// skip leading zeroes 
....................  
....................    sd=memchr(digits,tolower(*sc),base); 
....................    for(;sd!=0;) 
....................    { 
....................       x=x*base+(int16)(sd-digits); 
....................       ++sc; 
....................       sd=memchr(digits,tolower(*sc),base); 
....................    } 
....................    if(s1==sc) 
....................    { 
....................    StrtolGO: 
....................       if (endptr) 
....................       { 
....................          #IF LONG_POINTERS 
....................          *((int16 *)endptr)= s;  
....................          #ELSE 
....................          *((char *)endptr)=s; 
....................          #ENDIF 
....................       } 
....................    return 0; 
....................    } 
....................    if(sign=='-') 
....................       x  =-x; 
....................    if (endptr) 
....................    { 
....................         #IF LONG_POINTERS 
....................          *((int16 *)endptr)= sc;  
....................         #ELSE 
....................         *((char *)endptr)=sc; 
....................         #ENDIF 
....................    } 
....................    return x; 
.................... } 
....................  
.................... signed int8 system(char *string) 
.................... { 
....................    return 0; 
.................... } 
....................  
.................... size_t mblen(char *s,size_t n) 
.................... { 
....................    return strlen(s); 
.................... } 
....................  
.................... int8 mbtowc(wchar_t *pwc,char *s,size_t n) 
.................... { 
....................    *pwc=*s; 
....................    return 1; 
.................... } 
....................  
.................... int8 wctomb(char *s,wchar_t wchar) 
.................... { 
....................    *s=wchar; 
....................    return 1; 
.................... } 
....................  
.................... size_t mbstowcs(wchar_t *pwcs,char *s,size_t n) 
.................... { 
....................    strncpy(pwcs,s,n); 
....................    return strlen(pwcs); 
.................... } 
....................  
.................... size_t wcstombs(char *s,wchar_t *pwcs,size_t n) 
.................... { 
....................    strncpy(s,pwcs,n); 
....................    return strlen(s); 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // The random number implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... unsigned int32 _Randseed; 
....................  
.................... unsigned int16 rand(void) 
.................... { 
....................    _Randseed = _Randseed * 1103515245 + 12345; 
....................    return ((unsigned int16)(_Randseed >> 16) % RAND_MAX); 
.................... } 
....................  
.................... void srand(unsigned int32 seed) 
.................... { 
....................    _Randseed = seed; 
.................... } 
....................  
.................... //--------------------------------------------------------------------------- 
.................... // Searching and sorting utilities implementation 
.................... //--------------------------------------------------------------------------- 
....................  
.................... #if !defined(__PCD__) 
.................... typedef signed int8 (*_Cmpfun)(char * p1,char * p2);  
.................... #else  
.................... typedef signed int16 (*_Cmpfun)(char * p1,char * p2);  
.................... #endif 
....................  
....................  
....................  
.................... void qsort(char * qdata, unsigned int qitems, unsigned int qsize, _Cmpfun cmp) { 
....................    unsigned int m,j,i,l; 
....................    int1 done; 
....................    unsigned int8 t[16]; 
....................  
....................    m = qitems/2; 
....................    while( m > 0 ) { 
....................      for(j=0; j<(qitems-m); ++j) { 
....................         i = j; 
....................         do 
....................         { 
....................            done=1; 
....................            l = i+m; 
....................            if( (*cmp)(qdata+i*qsize, qdata+l*qsize) > 0 ) { 
....................               memcpy(t, qdata+i*qsize, qsize); 
....................               memcpy(qdata+i*qsize, qdata+l*qsize, qsize); 
....................               memcpy(qdata+l*qsize, t, qsize); 
....................               if(m <= i) 
....................                 i -= m; 
....................                 done = 0; 
....................            } 
....................         } while(!done); 
....................      } 
....................      m = m/2; 
....................    } 
.................... } 
....................  
....................  
.................... char *bsearch(char *key, char *base, size_t num, size_t width,_Cmpfun cmp) 
.................... { 
....................    char *p, *q; 
....................    size_t n; 
....................    size_t pivot; 
....................    signed int val; 
....................  
....................    p = base; 
....................    n = num; 
....................  
....................    while (n > 0) 
....................    { 
....................       pivot = n >> 1; 
....................       q = p + width * pivot; 
....................  
....................       val = (*cmp)(key, q); 
....................  
....................       if (val < 0) 
....................          n = pivot; 
....................       else if (val == 0) 
....................          return ((char *)q); 
....................       else { 
....................          p = q + width; 
....................          n -= pivot + 1; 
....................       } 
....................    } 
....................  
....................    return NULL;      // There's no match 
.................... } 
....................  
....................  
.................... #endif 
....................  
.................... #include <stdlibm.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
....................  
.................... /*********************************************************************/ 
.................... #ifndef _STDLIBM 
.................... #define _STDLIBM 
....................  
.................... /* Memory Management Functions*/ 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #if defined(__PCB__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int8 next; }node_t; 
.................... #elif defined(__PCM__) 
.................... typedef struct nodet { 
....................    unsigned int8 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCH__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #elif defined(__PCD__) 
.................... typedef struct nodet { 
....................    unsigned int16 size; 
....................    unsigned int16 next; }node_t; 
.................... #endif 
....................  
.................... #if !defined(STDLIBM_MANUAL_DYNAMIC_MEMORY) 
....................    #USE DYNAMIC_MEMORY 
.................... #endif 
....................  
.................... #ifndef debug_stdlibm 
....................    #define debug_stdlibm(s) 
.................... #else 
....................    #define __DO_DEBUG_STDLIBM 
....................     
....................    char g_DebugStdlibmStr[50]; 
....................     
....................    #if defined(__PCD__) 
....................       #if (defined(__PIC24E__)||defined(__dsPIC33E__)) 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x800)) || bit_test(x, 0)) 
....................       #else 
....................          #define INVALID_MEMORY_LOCATION(x) ((x >= (getenv("RAM")+0x1000)) || bit_test(x, 0)) 
....................       #endif 
....................    #else 
....................       #define INVALID_MEMORY_LOCATION(x) (x >= getenv("RAM")) 
....................    #endif 
.................... #endif 
....................  
.................... #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    static size_t _g_StdlibmCurrentBytesUsed = 0; 
....................    static size_t _g_StdlibmWorstCaseBytesUsed = 0; 
....................     
....................    #define _STDLIBM_TRACK_WORST_INC(_x) \ 
....................    do {  \ 
....................       _g_StdlibmCurrentBytesUsed += _x;   \ 
....................       if (_g_StdlibmCurrentBytesUsed > _g_StdlibmWorstCaseBytesUsed) \ 
....................          _g_StdlibmWorstCaseBytesUsed = _g_StdlibmCurrentBytesUsed;  \ 
....................    } while(0) 
....................     
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) _g_StdlibmCurrentBytesUsed-=_x 
.................... #else 
....................    #define _STDLIBM_TRACK_WORST_INC(_x) 
....................    #define _STDLIBM_TRACK_WORST_DEC(_x) 
.................... #endif 
....................  
.................... #include <memmgmt.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__PCH__) 
....................  #define _MEMMGMT_CSIZE 32768 
....................  #define _MEMMGMT_POS 15 
.................... #elif defined(__PCD__) 
....................    #define _MEMMGMT_CSIZE 32768 
....................    #define _MEMMGMT_POS 15 
.................... #else 
....................    #define _MEMMGMT_CSIZE 127 
....................    #define _MEMMGMT_POS 7 
.................... #endif 
....................  
.................... node_t * create_node(unsigned int16 size, node_t *ptr) // create node at given location 
.................... { 
....................    node_t *result; 
....................    result =ptr; 
....................    result->size=size; 
....................    result->next = NULL; 
....................    return result; 
.................... } 
.................... void update_node(node_t *node, unsigned int16 size) // update the size of given node 
.................... { 
....................    node->size=size; 
.................... } 
....................  
.................... /* Insert node immediately after place */ //old,new 
.................... void insert_node_after(node_t *place, node_t *node)// place the node after another given node 
.................... { 
....................     if (place->next==NULL) 
....................        node->next= NULL; 
....................     else 
....................        node->next=place->next; 
....................     place->next=node; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... void remove_node(node_t *node) {// remove the given node from the memlist 
....................    node_t *ptr; 
....................    for(ptr=__DYNAMIC_HEAD;ptr->next!=node;ptr=ptr->next); 
....................    ptr->next=node->next; 
....................    node=NULL; 
.................... } 
....................  
.................... ///////////////////////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if defined(__DO_DEBUG_STDLIBM) 
.................... void print_list() { // print the current memlist 
....................     node_t *node; 
....................     debug_stdlibm("\r\nThe list is \n\r"); 
....................     for(node = __DYNAMIC_HEAD; node != NULL; node = node->next) 
....................     { 
....................         sprintf(g_DebugStdlibmStr, "H:0x%lx S:0x%lx N:0x%lx\n\r", node, node->size, node->next); 
....................         debug_stdlibm(g_DebugStdlibmStr); 
....................         if (INVALID_MEMORY_LOCATION(node->next)) 
....................         { 
....................            debug_stdlibm("Breaking because of invalid next node\r\n"); 
....................            break; 
....................         }    
....................     } 
....................     sprintf(g_DebugStdlibmStr, "size of node_t %u\r\n",sizeof(node_t)); 
....................     debug_stdlibm(g_DebugStdlibmStr); 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
.................... void traverse() 
.................... { 
....................    node_t *node,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    node=__DYNAMIC_HEAD; 
....................    while(node!=NULL) 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "traverse() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          break; 
....................       }    
....................      #endif 
....................      if(!bit_test(node->size,_MEMMGMT_POS))// node free 
....................       { 
....................          nsize=node->size; 
....................          temp=(unsigned int16)node->next; 
....................         #if defined(__DO_DEBUG_STDLIBM) 
....................          if (INVALID_MEMORY_LOCATION(temp)) 
....................          { 
....................             sprintf(g_DebugStdlibmStr, "traverse() invalid temp (0x%LX)\r\n", node); 
....................             debug_stdlibm(g_DebugStdlibmStr); 
....................             break; 
....................          } 
....................         #endif 
....................          if(!bit_test(temp->size,_MEMMGMT_POS)&& (temp==((unsigned int16)node+nsize+sizeof(node_t))))//next node free and consecutive, so combine 
....................          { 
....................             nextsize=temp->size; 
....................             nsize+=nextsize+sizeof(node_t); 
....................             remove_node(temp); 
....................             update_node(node,nsize); 
....................          } 
....................          else 
....................          node=node->next; 
....................       } 
....................       else 
....................       node=node->next; 
....................    } 
.................... } 
....................  
.................... char *malloc(size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize; 
....................    #if defined(__PCD__) 
....................    if (size % 2) 
....................       size++; 
....................    #endif 
....................    node=__DYNAMIC_HEAD; 
....................     
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "malloc() size=%lu ", size); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................          
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, " invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=size) // node is free and > = req size 
....................       { 
....................          nsize=node->size;    //nsize = size of the node that "node" being pointed at 
....................          if(nsize>size +sizeof(node_t)) //node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................             insert_node_after(node,new); 
....................             update_node(node,size+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for mallocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       sprintf(g_DebugStdlibmStr, "%LX\r\n", (char *)node+sizeof(node_t)); 
....................       debug_stdlibm(g_DebugStdlibmStr); 
....................      #endif 
....................       _STDLIBM_TRACK_WORST_INC(size); 
....................       return (char *)node+sizeof(node_t); // return pounsigned int8er to allocated space 
....................    } 
.................... } 
....................  
.................... char *calloc(size_t nmemb,size_t size) 
.................... { 
....................    node_t *node,*new; 
....................    unsigned int16 nsize,resize; 
....................    node=__DYNAMIC_HEAD; 
....................    resize=nmemb*size; 
....................    #if defined(__PCD__) 
....................    if(resize%2) 
....................       resize++; 
....................    #endif 
....................    while(node!=NULL) // chk until end of memlist 
....................    { 
....................      #if defined(__DO_DEBUG_STDLIBM) 
....................       if (INVALID_MEMORY_LOCATION(node)) 
....................       { 
....................          sprintf(g_DebugStdlibmStr, "malloc() invalid node (0x%LX)\r\n", node); 
....................          debug_stdlibm(g_DebugStdlibmStr); 
....................          print_list(); 
....................          return(0); 
....................       } 
....................      #endif 
....................       if(!bit_test(node->size,_MEMMGMT_POS) && node->size >=resize)// node is free and > = req size 
....................       { 
....................          nsize=node->size; 
....................          if(nsize>resize+sizeof(node_t))//node > req size, so split and add new node to memlist 
....................          { 
....................             new=create_node(nsize-resize-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+resize); 
....................             insert_node_after(node,new); 
....................             update_node(node,resize+_MEMMGMT_CSIZE); 
....................          } 
....................          else//not enough space for new node so use original size 
....................          update_node(node,nsize+_MEMMGMT_CSIZE); 
....................          //end if 
....................          break; 
....................       }//end if 
....................       node=node->next; 
....................    }//end while 
....................    if(node==NULL)// reached end without finding an appropriate node 
....................    { 
....................       debug_stdlibm("Not enough memory for callocation\r\n"); 
....................       return NULL; 
....................    } 
....................    else 
....................    { 
....................       memset((unsigned int16)node+sizeof(node_t),0,resize);// initialize to 0 
....................       _STDLIBM_TRACK_WORST_INC(resize); 
....................       return (char *)(unsigned int16)node+sizeof(node_t);// return pounsigned int8er to allocated space 
....................    } 
.................... } 
.................... void free( void * ptr) 
.................... { 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................  
....................   #if defined(__DO_DEBUG_STDLIBM) 
....................    sprintf(g_DebugStdlibmStr, "free() 0x%LX\r\n", ptr); 
....................    debug_stdlibm(g_DebugStdlibmStr); 
....................   #endif 
....................  
....................    if(ptr==NULL) // not a valid pounsigned int8er 
....................       return; 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// node occupied 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          update_node(node,nsize); 
....................          ptr=NULL; 
....................          _STDLIBM_TRACK_WORST_DEC(nsize); 
....................       } 
....................       else // wrong input, return 
....................       { 
....................          ptr=NULL; 
....................          return; 
....................       } 
....................    } 
....................    traverse(); 
.................... } 
....................  
.................... char *realloc(void *ptr,size_t size) 
.................... { 
....................    node_t *node,*new,*temp; 
....................    unsigned int16 nsize,nextsize; 
....................    char *newptr; 
....................    #if defined(__PCD__) 
....................    if(size %2) 
....................       size++; 
....................    #endif 
....................    if(ptr==NULL)// null pounsigned int8er, so malloc the req memory 
....................       return(malloc(size)); 
....................    else if(size==0) 
....................    { 
....................       free(ptr); 
....................       return(NULL); 
....................    } 
....................    else 
....................    { 
....................       node=ptr-sizeof(node_t); 
....................       if(bit_test(node->size,_MEMMGMT_POS))// chk if valid pounsigned int8er 
....................       { 
....................          nsize=node->size-_MEMMGMT_CSIZE; 
....................          temp=(unsigned int16)node->next; 
....................          if(nsize>size)// block > req size 
....................          { 
....................         
....................                if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   nextsize=temp->size; 
....................                   remove_node(temp); 
....................                   new=create_node(nextsize+(nsize-size),(unsigned int16)node+size+sizeof(node_t)); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else if (nsize>size +sizeof(node_t))//node > req size, so split and add new node to memlist 
....................                { 
....................                   update_node(node,size+_MEMMGMT_CSIZE); // update block 
....................                   new=create_node(nsize-size-sizeof(node_t),(unsigned int16)node+sizeof(node_t)+size); 
....................                   insert_node_after(node,new); 
....................                   _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                   _STDLIBM_TRACK_WORST_INC(size); 
....................                } 
....................                else//not enough space for new node so use original size 
....................                update_node(node,nsize+_MEMMGMT_CSIZE); // update block 
....................  
....................          } 
....................          else // block < req size 
....................          { 
....................             if(!bit_test(temp->size,_MEMMGMT_POS) && (temp==((unsigned int16)node+nsize+sizeof(node_t))))// next block free and consecutive 
....................             { 
....................                nextsize=temp->size; 
....................                if(nextsize>=size-nsize) // next block >=difference 
....................                { 
....................                   if(nextsize>size-nsize+sizeof(node_t))//next node > req size, so split and add new node to memlist 
....................                   { 
....................                       update_node(node,size+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                       new=create_node(nextsize-(size-nsize),(unsigned int16)node+size+sizeof(node_t)); 
....................                       insert_node_after(node,new); 
....................                      _STDLIBM_TRACK_WORST_DEC(nsize); 
....................                      _STDLIBM_TRACK_WORST_INC(size); 
....................                   } 
....................                   else//not enough space for new node in next node, so use original size 
....................                   { 
....................                       update_node(node,nsize+nextsize+_MEMMGMT_CSIZE);// update block 
....................                       remove_node(temp); 
....................                   } 
....................                } 
....................                else  //next block free but too small for new size 
....................                { 
....................                   newptr = malloc(size);  //use malloc to find new block 
....................                   if(newptr == NULL) 
....................                      return(NULL);        //return NULL if malloc was unable to find new block 
....................                     
....................                   memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                   free(ptr);                    //free original block 
....................                   return(newptr);               //return new pointer 
....................                } 
....................             } 
....................             else  //next block not free 
....................             { 
....................                newptr = malloc(size);  //use malloc to find new block 
....................                if(newptr == NULL)       
....................                   return(NULL);        //return NULL if malloc was unable to find new block 
....................                 
....................                memcpy(newptr, ptr, nsize);   //copy original data to new block 
....................                free(ptr);                    //free original block 
....................                return(newptr);               //return new pointer 
....................             } 
....................          } 
....................          return (char *)node+sizeof(node_t); // return pounsigned int8er to the reallocated block 
....................       } 
....................       else // not allocated use malloc 
....................       { 
....................          return(malloc(size)); 
....................       } 
....................    } 
....................  } 
....................   
.................... typedef struct 
.................... { 
....................    size_t bytesUsed; 
....................    size_t largestUsedSeg; 
....................    int segmentsUsed; 
....................    size_t bytesFree; 
....................    size_t largestFreeSeg; 
....................    int segmentsFree; 
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    size_t worstCaseBytesUsed; 
....................   #endif 
.................... } heap_status_t; 
....................  
.................... void GetHeapStatus(heap_status_t *pHeapStatus) 
.................... { 
....................    heap_status_t status; 
....................    node_t *node; 
....................    unsigned int16 nsize; 
....................     
....................    node=__DYNAMIC_HEAD; 
....................     
....................    memset(&status, 0, sizeof(status)); 
....................  
....................    while(node!=NULL) 
....................    { 
....................       nsize = node->size; 
....................       node = node->next; 
....................        
....................       if(!bit_test(nsize, _MEMMGMT_POS)) // node free 
....................       { 
....................          status.bytesFree += nsize; 
....................           
....................          status.segmentsFree++; 
....................           
....................          if (nsize > status.largestFreeSeg) 
....................          { 
....................             status.largestFreeSeg = nsize; 
....................          } 
....................       } 
....................       else 
....................       { 
....................          bit_clear(nsize, _MEMMGMT_POS); 
....................           
....................          status.bytesUsed += nsize; 
....................           
....................          status.segmentsUsed++; 
....................           
....................          if (nsize > status.largestUsedSeg) 
....................          { 
....................             status.largestUsedSeg = nsize; 
....................          } 
....................       } 
....................    } 
....................  
....................   #if defined(STDLIBM_TRACK_WORST_CASE) 
....................    status.worstCaseBytesUsed = _g_StdlibmWorstCaseBytesUsed; 
....................   #endif 
....................  
....................    memcpy(pHeapStatus, &status, sizeof(heap_status_t)); 
.................... } 
.................... #ENDIF 
....................  
.................... #include <ieeefloat.c> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////                        ieeefloat.c                                //// 
.................... ////                                                                   //// 
.................... ////    This library converts IEEE float format to and from            //// 
.................... ////    the Microchip format used by PCB,PCM and PCH.                  //// 
.................... ////        (C) Copyright 1996,2006 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... float32 f_PICtoIEEE(unsigned int32) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format 
.................... PARAMS: 32 bit number 
.................... RETURNS: 32 bit Floating point number 
.................... */ 
.................... float32 f_PICtoIEEE(unsigned int32 pic) 
.................... { 
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.d = pic; 
....................     
....................    result.b[0] = data.b[3]; 
....................    result.b[1] = data.b[2]; 
....................    result.b[2] = data.b[1]; 
....................     
....................    if(bit_test(data.d,0)) 
....................       bit_set(result.b[2],7); 
....................    else 
....................       bit_clear(result.b[2],7); 
....................     
....................    shift_right(&data.b[0],1,bit_test(data.b[1],7)); 
....................    result.b[3] = data.b[0]; 
....................     
....................    return(result.f); 
.................... } 
.................... #else 
.................... /* 
.................... int32 f_PICtoIEEE(float f) 
.................... PURPOSE: This function converts float from CCS -PIC format to IEEE format in little endian mode 
.................... PARAMS: Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... int32 f_PICtoIEEE(float f) 
.................... { 
....................  
....................    int32 * ret; 
....................    #locate f=0x20 
....................  
....................    ret = &f;    
*
00DF2:  MOVLB  1
00DF4:  CLRF   xB6
00DF6:  MOVLW  20
00DF8:  MOVWF  xB5
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlf   0x21 
....................       rrf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
00DFA:  RLCF   21,F
....................       rrcf   0x20 
00DFC:  RRCF   20,F
....................       rrcf   0x21    
00DFE:  RRCF   21,F
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
00E00:  MOVF   20,W
....................       xorwf  0x23,W 
00E02:  XORWF  23,W
....................       xorwf  0x23,F 
00E04:  XORWF  23,F
....................       xorwf  0x23,W 
00E06:  XORWF  23,W
....................       movwf  0x20 
00E08:  MOVWF  20
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
00E0A:  MOVF   21,W
....................       xorwf  0x22,W 
00E0C:  XORWF  22,W
....................       xorwf  0x22,F 
00E0E:  XORWF  22,F
....................       xorwf  0x22,W 
00E10:  XORWF  22,W
....................       movwf  0x21 
00E12:  MOVWF  21
....................     
....................    #endasm 
....................     
....................    return *ret; 
00E14:  MOVFF  1B6,03
00E18:  MOVFF  1B5,FE9
00E1C:  MOVFF  03,FEA
00E20:  MOVFF  FEF,00
00E24:  MOVFF  FEC,01
00E28:  MOVFF  FEC,02
00E2C:  MOVFF  FEC,03
00E30:  MOVLB  0
00E32:  GOTO   18D2 (RETURN)
.................... } 
.................... #endif 
....................  
.................... #ifdef __PCD__ 
.................... /* 
.................... unsigned int32 f_IEEEtoPIC(float32 f) 
.................... PURPOSE: This function converts IEEE format to float CCS -PIC format 
.................... PARAMS: 32 bit Floating point number 
.................... RETURNS: 32 bit number 
.................... */ 
.................... unsigned int32 f_IEEEtoPIC(float32 ieee) 
.................... { 
....................    union{ 
....................       unsigned int32 d; 
....................       unsigned int8 b[4]; 
....................    } result; 
....................     
....................    union{ 
....................       float32 f; 
....................       unsigned int8 b[4]; 
....................    } data; 
....................     
....................    data.f = ieee; 
....................     
....................    result.b[3] = data.b[0]; 
....................    result.b[2] = data.b[1]; 
....................    result.b[1] = data.b[2]; 
....................     
....................    if(bit_test(data.b[3],7)) 
....................       bit_set(result.b[1],7); 
....................    else 
....................       bit_clear(result.b[1],7); 
....................     
....................    result.b[0] = data.b[3]; 
....................     
....................    shift_left(&result.b[0],1,bit_test(data.b[2],7)); 
....................     
....................    return(result.d);    
.................... } 
.................... #else 
.................... /* 
.................... float f_IEEEtoPIC(int32 f) 
.................... PURPOSE: This function converts IEEE format to a float 
.................... PARAMS: 32 bit number 
.................... RETURNS: Floating point number 
.................... */ 
.................... float f_IEEEtoPIC(int32 f) 
.................... { 
....................  
....................    float * ret; 
....................    #locate f=0x20 
....................     
....................    ret = &f; 
....................     
....................    #asm 
....................  
....................    // swap the outer bytes 
....................       movf   0x20,W 
....................       xorwf  0x23,W 
....................       xorwf  0x23,F 
....................       xorwf  0x23,W 
....................       movwf  0x20 
....................  
....................    // swap the inner bytes 
....................       movf   0x21,W 
....................       xorwf  0x22,W 
....................       xorwf  0x22,F 
....................       xorwf  0x22,W 
....................       movwf  0x21 
....................  
....................    #endasm 
....................  
....................    #if defined(__PCB__) || defined(__PCM__) 
....................       #asm 
....................  
....................       // switch the bits 
....................       rlf   0x21 
....................       rlf   0x20 
....................       rrf   0x21 
....................        
....................       #endasm 
....................    #elif defined(__PCH__) 
....................       #asm 
....................        
....................       // switch the bits 
....................       rlcf   0x21 
....................       rlcf   0x20 
....................       rrcf   0x21    
....................        
....................       #endasm 
....................    #else 
....................       #error Invalid complier defined 
....................    #endif 
....................     
....................    return *ret; 
.................... } 
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... /*Hardware defines*/ 
.................... #define COMPILACION_DATE    __DATE__ 
.................... #define COMPILACION_TIME    __TIME__ 
.................... #define FW_VERSION  1.0 
.................... #define HW_NAME "Galio Modbus Slave Demo" 
....................  
.................... #fuses HS 
.................... #use delay(crystal=20mhz) 
....................  
.................... #use rs232(baud=115200,parity=N,UART1,bits=8,stream=DEBUG,errors) 
.................... //#use rs232(baud=115200,parity=N,UART3,bits=8,stream=LAN,errors) 
.................... //#use rs232(baud=9600,parity=N,UART2,bits=8,stream=DISPLAY,errors) 
.................... //#use rs232(baud=9600,parity=N,UART5,bits=8,stream=MAX,errors) 
....................  
.................... #define DEBUG_MSG(msg) fprintf(DEBUG, msg) 
.................... #define DEBUG_DATA(msg,data) fprintf(DEBUG,msg,data) 
....................  
....................  
.................... //MODBUS DEFINES 
.................... #define MODBUS_PROTOCOL             MODBUS_PROTOCOL_SERIAL 
.................... #define MODBUS_TYPE                 MODBUS_TYPE_SLAVE 
.................... #define MODBUS_SERIAL_TYPE          MODBUS_RTU     //use MODBUS_ASCII for ASCII mode 
.................... #define MODBUS_SERIAL_RX_BUFFER_SIZE 64 
.................... #define MODBUS_SERIAL_BAUD          115200 
.................... #define MODBUS_PARITY               "NONE" 
.................... #define MODBUS_SERIAL_INT_SOURCE    MODBUS_INT_RDA5 
.................... #define MODBUS_SERIAL_RX_PIN        RX_MODBUS 
.................... #define MODBUS_SERIAL_TX_PIN        TX_MODBUS 
.................... #define MODBUS_SERIAL_ENABLE_PIN    TX_ENABLE 
.................... #define MODBUS_SERIAL_RX_ENABLE     RX_ENABLE 
.................... //#define MODBUS_SERIAL_TIMEOUT       100000 
....................  
....................  
.................... //#include <bootloader.h> 
.................... #include "tuna-modbus/modbus.c" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.c                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... ////  How to Use:                                                                     //// 
.................... ////                                                                                  //// 
.................... ////  Include just this file, modbus.c, in your main program. Before including this   //// 
.................... ////  file define the constants below for your needs.                                 //// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #include "modbus.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                     modbus.h                                     //// 
.................... ////                                                                                  //// 
.................... ////           MODBUS protocol driver for serial and TCP/IP communications.           //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// DEFINES:                                                                         //// 
.................... ////  MODBUS_PROTOCOL               MODBUS_PROTOCOL_SERIAL or MODBUS_PROTOCOL_TCPIP   //// 
.................... ////                                                                                  //// 
.................... //// SERIAL DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBUS_TYPE_MASTER or MODBUS_TYPE_SLAVE           //// 
.................... ////  MODBUS_SERIAL_INT_SOURCE      Source of interrupts                              //// 
.................... ////                                (MODBUS_INT_EXT,MODBUS_INT_RDA,MODBUS_INT_RDA2,   //// 
.................... ////                                   MODBUS_INT_RDA3,MODBUS_INT_RDA4)               //// 
.................... ////  MODBUS_SERIAL_TYPE            MODBUS_RTU or MODBUS_ASCII                        //// 
.................... ////  MODBUS_SERIAL_BAUD            Valid baud rate for serial                        //// 
.................... ////  MODBUS_SERIAL_RX_PIN          Valid pin for serial receive                      //// 
.................... ////  MODBUS_SERIAL_TX_PIN          Valid pin for serial transmit                     //// 
.................... ////  MODBUS_SERIAL_ENABLE_PIN      Valid pin for serial enable, rs485 only           //// 
.................... ////  MODBUS_SERIAL_RX_ENABLE       Valid pin for serial rcv enable, rs485 only       //// 
.................... ////  MODBUS_SERAIL_RX_BUFFER_SIZE  Size of the receive buffer                        //// 
.................... ////                                                                                  //// 
.................... //// TCP/IP DEFINES:                                                                  //// 
.................... ////  MODBUS_TYPE                   MODBYS_TYPE_CLIENT or MODBUS_TYPE_SERVER          //// 
.................... ////  MODBUS_SERVER_LISTEN_PORT     Port server/client listens/sends messages to      //// 
.................... ////                                   (default 502)                                  //// 
.................... ////  MODBUS_LISTEN_SOCKETS         Number of sockets server listens to (default 1)   //// 
.................... ////  MODBUS_BUFFER_SIZE            Size of receive and transmit buffers (default 64) //// 
.................... ////  MODBUS_SERVER_TIMEOUT         Time is seconds client will wait for response     //// 
.................... ////                                   from server before setting TIMEOUT exception   //// 
.................... ////                                   (default 5)                                    //// 
.................... ////  MODBUS_SERVER_ADDR_0          TCP/IP address client connects to MSB             //// 
.................... ////  MODBUS_SERVER_ADDR_1          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_2          TCP/IP address client connects to                 //// 
.................... ////  MODBUS_SERVER_ADDR_3          TCP/IP address client connects to LSB             //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  May 8, 2009       Made PCD Compatible                                           //// 
.................... ////  August 21, 2009   Added Modbus ASCII protocol                                   //// 
.................... ////  May 20, 2010      Changed variables to unsigned for PCD and if #device ANSI is  //// 
.................... ////                    used for PCM or PCH. Fixed bug when multiple UARTS are used   //// 
.................... ////                    on PIC.                                                       //// 
.................... ////  July 20, 2011     Seperated modbus.c into 7 files, including this one. The code //// 
.................... ////                    was seperated into header and c files for the Physical and    //// 
.................... ////                    Application layers, and RTU code and ASCII code.              //// 
.................... ////  November 1, 2011  Added Modbus TCP/IP protocol.                                 //// 
.................... ////  Janurary 9, 2013  Added support for Even and Odd Parity for RTU and ASCII       //// 
.................... ////                    modes.                                                        //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2010 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_H 
.................... #define MODBUS_H 
....................  
.................... /*Some defines so we can use identifiers to set things up*/ 
.................... #define MODBUS_PROTOCOL_SERIAL 0 
.................... #define MODBUS_PROTOCOL_TCPIP  100 
.................... #define MODBUS_TYPE_MASTER 99999 
.................... #define MODBUS_TYPE_SLAVE  88888 
.................... #define MODBUS_TYPE_CLIENT 20 
.................... #define MODBUS_TYPE_SERVER 21 
.................... #define MODBUS_INT_RDA     77777 
.................... #define MODBUS_INT_RDA2    66666 
.................... #define MODBUS_INT_RDA3    44444 
.................... #define MODBUS_INT_RDA4    33333 
.................... #define MODBUS_INT_RDA5    22222 
.................... #define MODBUS_INT_EXT     55555 
.................... #define MODBUS_RTU         1 
.................... #define MODBUS_ASCII       2 
.................... #define MODBUS_TIMER_NOISR 13 
.................... #define MODBUS_TIMER_ISR   12 
.................... #define MODBUS_TIMER_T1    14 
.................... #define MODBUS_TIMER_T2    15 
....................  
.................... #ifndef MODBUS_PROTOCOL 
....................  #define MODBUS_PROTOCOL MODBUS_PROTOCOL_SERIAL 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE MODBUS_TYPE_MASTER 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TYPE 
....................   #define MODBUS_SERIAL_TYPE MODBUS_RTU 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_INT_SOURCE 
....................   #define MODBUS_SERIAL_INT_SOURCE MODBUS_INT_RDA   // Select between external interrupt 
....................  #endif                                             // or asynchronous serial interrupt 
....................  
....................  #ifndef MODBUS_SERIAL_BAUD 
....................   #define MODBUS_SERIAL_BAUD 9600 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_PIN 
....................   #define MODBUS_SERIAL_RX_PIN       PIN_C7   // Data receive pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TX_PIN 
....................   #define MODBUS_SERIAL_TX_PIN       PIN_C6   // Data transmit pin 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_ENABLE_PIN 
....................   #define MODBUS_SERIAL_ENABLE_PIN   0   // Controls DE pin.  RX low, TX high. 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_ENABLE 
....................   #define MODBUS_SERIAL_RX_ENABLE    0   // Controls RE pin.  Should keep low. 
....................  #endif 
....................  
....................  #ifndef MODBUS_PARITY 
....................   #define MODBUS_PARITY "EVEN" 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_TIMEOUT 
....................   #if (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................    #define MODBUS_SERIAL_TIMEOUT    1000000 
....................   #else 
....................    #define MODBUS_SERIAL_TIMEOUT      10000     //in us 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERIAL_RX_BUFFER_SIZE 
....................   #define MODBUS_SERIAL_RX_BUFFER_SIZE  64      //size of send/rcv buffer 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_UPDATE 
....................   #define MODBUS_TIMER_UPDATE MODBUS_TIMER_ISR 
....................  #endif 
....................  
....................  #ifndef MODBUS_TIMER_USED 
....................   #define MODBUS_TIMER_USED MODBUS_TIMER_T1 
....................  #endif 
....................  
.................... #else ///////////////////////// MODBUS TCP/IP PROTOCOL ///////////////////////// 
....................  #ifndef MODBUS_TYPE 
....................   #define MODBUS_TYPE   MODBUS_TYPE_CLIENT 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_LISTEN_PORT 
....................   #define MODBUS_SERVER_LISTEN_PORT    502   //this is the default listen port for MODBUS TCP/IP protocol 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_SERVER) 
....................   #ifndef MODBUS_LISTEN_SOCKETS 
....................    #define MODBUS_LISTEN_SOCKETS     1 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef MODBUS_BUFFER_SIZE 
....................   #define MODBUS_BUFFER_SIZE   64 
....................  #endif 
....................  
....................  #ifndef MODBUS_SERVER_TIMEOUT 
....................   #define MODBUS_SERVER_TIMEOUT  5  //time in seconds that client will wait for server response before timeout 
....................  #endif 
....................  
....................  #if (MODBUS_TYPE == MODBUS_TYPE_CLIENT) 
....................   #ifndef MODBUS_SERVER_ADDR_0 
....................    #define MODBUS_SERVER_ADDR_0  192 
....................    #define MODBUS_SERVER_ADDR_1  168 
....................    #define MODBUS_SERVER_ADDR_2  100 
....................    #define MODBUS_SERVER_ADDR_3  140 
....................   #endif 
....................  #endif 
....................  
....................  #ifndef debug_printf 
....................   #define debug_printf(a,b,c,d,e,f,g,h,i,k,l,m,n,o,p,q,r,s,t,u) 
....................  #endif 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include "modbus_phy_layer_tcpip.h" 
.................... #else 
....................  #include "modbus_phy_layer.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U5STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5) 
....................          #if getenv("sfr_valid:TXSTA5") 
....................             #byte TXSTA=getenv("sfr:TXSTA5") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX5STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include "modbus_app_layer_tcpip.h" 
.................... #else 
....................  #include "modbus_app_layer.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include "modbus_phy_layer.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U5STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5) 
....................          #if getenv("sfr_valid:TXSTA5") 
....................             #byte TXSTA=getenv("sfr:TXSTA5") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX5STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
.................... #endif 
....................  
.................... #endif //MODBUS_H 
....................  
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_SERIAL) 
....................  #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................   #include "modbus_phy_layer_rtu.c" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                              modbus_phy_layer_rtu.c                              //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_RTU_C 
.................... #define MODBUS_PHY_LAYER_RTU_C 
....................  
.................... #include "modbus_phy_layer.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_phy_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////      Physical layer of the MODBUS protocol driver for serial communications.     //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated Physical Layer functions definitions into this    //// 
.................... ////                      file from modbus.c                                          //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_PHY_LAYER_H 
.................... #define MODBUS_PHY_LAYER_H 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... #if (MODBUS_SERIAL_TYPE == MODBUS_RTU) 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    modbus_timeout_enabled = 0;\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #else 
.................... #define MODBUS_SERIAL_WAIT_FOR_RESPONSE()\ 
.................... {\ 
....................    if(address)\ 
....................    {\ 
....................       while(!modbus_kbhit() && --modbus_serial_wait)\ 
....................          delay_us(1);\ 
....................       if(!modbus_serial_wait)\ 
....................          modbus_rx.error=TIMEOUT;\ 
....................    }\ 
....................    modbus_serial_wait = MODBUS_SERIAL_TIMEOUT;\ 
.................... } 
.................... #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
....................    #if defined(__PCD__) 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #word TXSTA=getenv("SFR:U1STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #word TXSTA=getenv("SFR:U2STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #word TXSTA=getenv("SFR:U3STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U4STA") 
....................          #bit TRMT=TXSTA.8 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #word TXSTA=getenv("SFR:U5STA") 
....................          #bit TRMT=TXSTA.8 
....................       #endif 
....................    #else 
....................       #if (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA) 
....................          #if getenv("sfr_valid:TXSTA") 
....................             #byte TXSTA=getenv("sfr:TXSTA") 
....................          #elif getenv("sfr_valid:TXSTA1") 
....................             #byte TXSTA=getenv("sfr:TXSTA1") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX1STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2) 
....................          #if getenv("sfr_valid:TXSTA2") 
....................             #byte TXSTA=getenv("sfr:TXSTA2") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX2STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3) 
....................          #if getenv("sfr_valid:TXSTA3") 
....................             #byte TXSTA=getenv("sfr:TXSTA3") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX3STA") 
....................          #endif 
....................      #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4) 
....................          #if getenv("sfr_valid:TXSTA4") 
....................             #byte TXSTA=getenv("sfr:TXSTA4") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX4STA") 
....................          #endif 
....................       #elif (MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5) 
....................          #if getenv("sfr_valid:TXSTA5") 
....................             #byte TXSTA=getenv("sfr:TXSTA5") 
....................          #else 
....................             #byte TXSTA=getenv("sfr:TX5STA") 
....................          #endif 
....................       #endif 
....................       #bit TRMT=TXSTA.1 
....................    #endif 
.................... #endif 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE != MODBUS_INT_EXT) 
.................... #define WAIT_FOR_HW_BUFFER()\ 
.................... {\ 
....................    while(!TRMT);\ 
.................... } 
.................... #endif 
....................  
.................... int1 modbus_serial_new=0; 
....................  
.................... /******************************************************************** 
.................... These exceptions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to communicate problems with the transmission back 
.................... to the master who can also use these to easily check the exceptions. 
.................... The first exception is the only one that is not part of the protocol 
.................... specification.  The TIMEOUT exception is returned when no slave 
.................... responds to the master's request within the timeout period. 
.................... ********************************************************************/ 
.................... typedef enum _exception{ILLEGAL_FUNCTION=1,ILLEGAL_DATA_ADDRESS=2, 
.................... ILLEGAL_DATA_VALUE=3,SLAVE_DEVICE_FAILURE=4,ACKNOWLEDGE=5,SLAVE_DEVICE_BUSY=6, 
.................... MEMORY_PARITY_ERROR=8,GATEWAY_PATH_UNAVAILABLE=10,GATEWAY_TARGET_NO_RESPONSE=11, 
.................... TIMEOUT=12} exception; 
....................  
.................... /******************************************************************** 
.................... These functions are defined in the MODBUS protocol.  These can be 
.................... used by the slave to check the incomming function.  See 
.................... ex_modbus_slave.c for example usage. 
.................... ********************************************************************/ 
.................... typedef enum _function{FUNC_READ_COILS=0x01,FUNC_READ_DISCRETE_INPUT=0x02, 
.................... FUNC_READ_HOLDING_REGISTERS=0x03,FUNC_READ_INPUT_REGISTERS=0x04, 
.................... FUNC_WRITE_SINGLE_COIL=0x05,FUNC_WRITE_SINGLE_REGISTER=0x06, 
.................... FUNC_READ_EXCEPTION_STATUS=0x07,FUNC_DIAGNOSTICS=0x08, 
.................... FUNC_GET_COMM_EVENT_COUNTER=0x0B,FUNC_GET_COMM_EVENT_LOG=0x0C, 
.................... FUNC_WRITE_MULTIPLE_COILS=0x0F,FUNC_WRITE_MULTIPLE_REGISTERS=0x10, 
.................... FUNC_REPORT_SLAVE_ID=0x11,FUNC_READ_FILE_RECORD=0x14, 
.................... FUNC_WRITE_FILE_RECORD=0x15,FUNC_MASK_WRITE_REGISTER=0x16, 
.................... FUNC_READ_WRITE_MULTIPLE_REGISTERS=0x17,FUNC_READ_FIFO_QUEUE=0x18} function; 
....................  
.................... /******************************************************************** 
.................... Our receive struct.  This is used when receiving data as a master or 
.................... slave.  Once a message is sent to you with your address, you should 
.................... begin processing that message.  Refer to ex_modbus_slave.c to see 
.................... how to properly use this structure. 
.................... ********************************************************************/ 
.................... struct 
.................... { 
....................    unsigned int8 address; 
....................    unsigned int8 len;                       //number of bytes in the message received 
....................    function func;                           //the function of the message received 
....................    exception error;                         //error recieved, if any 
....................    unsigned int8 data[MODBUS_SERIAL_RX_BUFFER_SIZE]; //data of the message received 
.................... } modbus_rx; 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Custom Commands                                                             //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_start(address,func)                                          //// 
.................... ////    - Setup serial line to begin sending.  Once this is called, you can send data //// 
.................... ////      using modbus_serial_putc().  Should only be used for custom commands.       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_send_stop()                                                       //// 
.................... ////    - Must be called to finalize the send when modbus_serial_send_start is used.  //// 
.................... ////                                                                                  //// 
.................... ////  modbus_serial_putc(unsigned int8 c)                                             //// 
.................... ////    - Sends a character onto the serial line                                      //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func); 
....................  
.................... // Purpose:    Sends a message stop 
.................... // Inputs:     none 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop(); 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c); 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////  For Init                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void); 
....................  
.................... #endif //MODBUS_PHY_LAYER_H 
....................  
....................  
.................... #if (MODBUS_TIMER_USED == MODBUS_TIMER_T1) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, ISR) 
*
00328:  MOVFF  1E2,00
0032C:  MOVFF  1E3,01
00330:  CLRF   02
00332:  BCF    FD8.0
00334:  RLCF   00,F
00336:  RLCF   01,F
00338:  RLCF   02,F
0033A:  BCF    FD8.0
0033C:  RLCF   00,F
0033E:  RLCF   01,F
00340:  RLCF   02,F
00342:  BCF    FD8.0
00344:  RLCF   00,F
00346:  RLCF   01,F
00348:  RLCF   02,F
0034A:  BCF    FD8.0
0034C:  RLCF   00,F
0034E:  RLCF   01,F
00350:  RLCF   02,F
00352:  BCF    FD8.0
00354:  RLCF   00,F
00356:  RLCF   01,F
00358:  RLCF   02,F
0035A:  BCF    FD8.0
0035C:  RLCF   00,F
0035E:  RLCF   01,F
00360:  RLCF   02,F
00362:  MOVFF  02,6E
00366:  MOVFF  01,FCE
0036A:  MOVFF  00,FCD
0036E:  RETURN 0
*
00E36:  MOVFF  6E,01
00E3A:  MOVF   FCD,W
00E3C:  MOVFF  FCE,03
00E40:  MOVLB  E
00E42:  BCF    x2E.0
00E44:  MOVWF  02
00E46:  MOVLB  0
00E48:  MOVF   x6E,W
00E4A:  SUBWF  01,W
00E4C:  BZ    0E56
00E4E:  MOVF   FCD,W
00E50:  MOVFF  FCE,03
00E54:  BRA    0E58
00E56:  MOVF   02,W
00E58:  MOVWF  00
00E5A:  MOVFF  03,01
00E5E:  MOVFF  6E,02
00E62:  RRCF   02,F
00E64:  RRCF   01,F
00E66:  RRCF   00,F
00E68:  RRCF   02,F
00E6A:  RRCF   01,F
00E6C:  RRCF   00,F
00E6E:  RRCF   02,F
00E70:  RRCF   01,F
00E72:  RRCF   00,F
00E74:  RRCF   02,F
00E76:  RRCF   01,F
00E78:  RRCF   00,F
00E7A:  RRCF   02,F
00E7C:  RRCF   01,F
00E7E:  RRCF   00,F
00E80:  RRCF   02,F
00E82:  RRCF   01,F
00E84:  RRCF   00,F
00E86:  MOVLB  E
00E88:  BSF    x2E.0
00E8A:  MOVLB  0
00E8C:  GOTO   0ED2 (RETURN)
....................   #else 
....................     #USE TIMER(TIMER=1,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #elif (MODBUS_TIMER_USED == MODBUS_TIMER_T2) 
....................   #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_ISR) 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, ISR) 
....................   #else 
....................     #USE TIMER(TIMER=2,TICK=.1ms,BITS=16, NOISR) 
....................   #endif 
.................... #endif 
....................  
.................... #define MODBUS_GETDATA_TIMEOUT 40 
....................  
.................... #if( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART1, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA2 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART2, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA2);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA3 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART3, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA3);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA4 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART4, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA4);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_RDA5 ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, errors) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, errors) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, UART5, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, errors) 
*
0030E:  MOVLB  E
00310:  BTFSS  x37.5
00312:  BRA    0310
00314:  MOVFF  EE0,28
00318:  MOVFF  EDC,01
0031C:  BTFSS  28.1
0031E:  BRA    0324
00320:  BCF    xE0.4
00322:  BSF    xE0.4
00324:  MOVLB  0
00326:  RETURN 0
*
00F18:  MOVLB  E
00F1A:  BTFSS  x37.4
00F1C:  BRA    0F1A
00F1E:  MOVLB  1
00F20:  MOVF   xC6,W
00F22:  MOVLB  E
00F24:  MOVWF  xDD
00F26:  BTFSS  xE1.1
00F28:  BRA    0F26
00F2A:  MOVLW  1C
00F2C:  MOVWF  00
00F2E:  DECFSZ 00,F
00F30:  BRA    0F2E
00F32:  MOVLB  0
00F34:  GOTO   0F3E (RETURN)
....................   #endif 
....................    #define RCV_OFF() {disable_interrupts(INT_RDA5);} 
.................... #elif( MODBUS_SERIAL_INT_SOURCE == MODBUS_INT_EXT ) 
....................   #if MODBUS_PARITY == "EVEN" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=E, stream=MODBUS_SERIAL, disable_ints) 
....................   #elif MODBUS_PARITY == "ODD" 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=1, parity=O, stream=MODBUS_SERIAL, disable_ints) 
....................   #else 
....................    #use rs232(baud=MODBUS_SERIAL_BAUD, xmit=MODBUS_SERIAL_TX_PIN, rcv=MODBUS_SERIAL_RX_PIN, bits=8, stop=2, parity=N, stream=MODBUS_SERIAL, disable_ints) 
....................   #endif 
....................    #if defined(__PCD__) 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT0);} 
....................    #else 
....................    #define RCV_OFF() {disable_interrupts(INT_EXT);} 
....................    #endif 
.................... #else 
....................    #error Please define a correct interrupt source 
.................... #endif 
....................  
.................... /* status of between byte timeout */ 
.................... int1 modbus_timeout_enabled = false; 
....................  
.................... #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
.................... unsigned int32 modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
.................... #endif 
....................  
.................... /*Stages of MODBUS reception.  Used to keep our ISR fast enough.*/ 
.................... enum {MODBUS_GETADDY=0, MODBUS_GETFUNC=1, MODBUS_GETDATA=2} modbus_serial_state = 0; 
....................  
....................  
.................... /*Global value holding our current CRC value.*/ 
.................... union 
.................... { 
....................    unsigned int8 b[2]; 
....................    unsigned int16 d; 
.................... } modbus_serial_crc; 
....................  
....................  
.................... /* Table of CRC values for highorder byte */ 
.................... const unsigned char modbus_auchCRCHi[] = { 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01, 
.................... 0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x01,0xC0, 
.................... 0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01, 
.................... 0xC0,0x80,0x41,0x00,0xC1,0x81,0x40,0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41, 
.................... 0x00,0xC1,0x81,0x40,0x01,0xC0,0x80,0x41,0x01,0xC0,0x80,0x41,0x00,0xC1,0x81, 
.................... 0x40 
.................... }; 
....................  
.................... /* Table of CRC values for loworder byte */ 
.................... const unsigned char modbus_auchCRCLo[] = { 
.................... 0x00,0xC0,0xC1,0x01,0xC3,0x03,0x02,0xC2,0xC6,0x06,0x07,0xC7,0x05,0xC5,0xC4, 
.................... 0x04,0xCC,0x0C,0x0D,0xCD,0x0F,0xCF,0xCE,0x0E,0x0A,0xCA,0xCB,0x0B,0xC9,0x09, 
.................... 0x08,0xC8,0xD8,0x18,0x19,0xD9,0x1B,0xDB,0xDA,0x1A,0x1E,0xDE,0xDF,0x1F,0xDD, 
.................... 0x1D,0x1C,0xDC,0x14,0xD4,0xD5,0x15,0xD7,0x17,0x16,0xD6,0xD2,0x12,0x13,0xD3, 
.................... 0x11,0xD1,0xD0,0x10,0xF0,0x30,0x31,0xF1,0x33,0xF3,0xF2,0x32,0x36,0xF6,0xF7, 
.................... 0x37,0xF5,0x35,0x34,0xF4,0x3C,0xFC,0xFD,0x3D,0xFF,0x3F,0x3E,0xFE,0xFA,0x3A, 
.................... 0x3B,0xFB,0x39,0xF9,0xF8,0x38,0x28,0xE8,0xE9,0x29,0xEB,0x2B,0x2A,0xEA,0xEE, 
.................... 0x2E,0x2F,0xEF,0x2D,0xED,0xEC,0x2C,0xE4,0x24,0x25,0xE5,0x27,0xE7,0xE6,0x26, 
.................... 0x22,0xE2,0xE3,0x23,0xE1,0x21,0x20,0xE0,0xA0,0x60,0x61,0xA1,0x63,0xA3,0xA2, 
.................... 0x62,0x66,0xA6,0xA7,0x67,0xA5,0x65,0x64,0xA4,0x6C,0xAC,0xAD,0x6D,0xAF,0x6F, 
.................... 0x6E,0xAE,0xAA,0x6A,0x6B,0xAB,0x69,0xA9,0xA8,0x68,0x78,0xB8,0xB9,0x79,0xBB, 
.................... 0x7B,0x7A,0xBA,0xBE,0x7E,0x7F,0xBF,0x7D,0xBD,0xBC,0x7C,0xB4,0x74,0x75,0xB5, 
.................... 0x77,0xB7,0xB6,0x76,0x72,0xB2,0xB3,0x73,0xB1,0x71,0x70,0xB0,0x50,0x90,0x91, 
.................... 0x51,0x93,0x53,0x52,0x92,0x96,0x56,0x57,0x97,0x55,0x95,0x94,0x54,0x9C,0x5C, 
.................... 0x5D,0x9D,0x5F,0x9F,0x9E,0x5E,0x5A,0x9A,0x9B,0x5B,0x99,0x59,0x58,0x98,0x88, 
.................... 0x48,0x49,0x89,0x4B,0x8B,0x8A,0x4A,0x4E,0x8E,0x8F,0x4F,0x8D,0x4D,0x4C,0x8C, 
.................... 0x44,0x84,0x85,0x45,0x87,0x47,0x46,0x86,0x82,0x42,0x43,0x83,0x41,0x81,0x80, 
.................... 0x40 
.................... }; 
....................  
.................... // Purpose:    Enable data reception 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void RCV_ON(void) 
.................... { 
....................    #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................       while(kbhit(MODBUS_SERIAL)) {fgetc(MODBUS_SERIAL);}  //Clear RX buffer. Clear RDA interrupt flag. Clear overrun error flag. 
*
004FC:  MOVLB  E
004FE:  BTFSS  x37.5
00500:  BRA    050A
00502:  MOVLB  0
00504:  RCALL  030E
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................          clear_interrupt(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................          clear_interrupt(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................          clear_interrupt(INT_RDA3); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
00506:  BRA    04FC
00508:  MOVLB  E
....................          clear_interrupt(INT_RDA4); 
....................       #else 
....................          clear_interrupt(INT_RDA5); 
0050A:  MOVF   xDC,W
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
0050C:  BCF    F85.7
0050E:  BCF    F7D.7
....................       #endif 
....................  
....................       #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
....................         enable_interrupts(INT_RDA); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
....................         enable_interrupts(INT_RDA2); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
....................         enable_interrupts(INT_RDA3); 
....................       #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
....................         enable_interrupts(INT_RDA4); 
....................       #else 
....................         enable_interrupts(INT_RDA5); 
00510:  BSF    x2D.5
....................       #endif 
....................    #else 
00512:  MOVLB  0
00514:  RETURN 0
....................       #if defined(__PCD__) 
....................          clear_interrupt(INT_EXT0); 
....................       #else 
....................          clear_interrupt(INT_EXT); 
....................       #endif 
....................  
....................       ext_int_edge(H_TO_L); 
....................  
....................       #if (MODBUS_SERIAL_RX_ENABLE!=0) 
....................          output_low(MODBUS_SERIAL_RX_ENABLE); 
....................       #endif 
....................  
....................       #if defined(__PCD__) 
....................          enable_interrupts(INT_EXT0); 
....................       #else 
....................          enable_interrupts(INT_EXT); 
....................       #endif 
....................    #endif 
.................... } 
....................  
.................... // Purpose:    Start our timeout timer 
.................... // Inputs:     Enable, used to turn timer on/off 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_enable_timeout(int1 enable) 
.................... { 
....................    modbus_timeout_enabled = enable; 
*
00370:  BCF    29.1
00372:  MOVLB  1
00374:  BTFSC  xE1.0
00376:  BSF    29.1
....................    set_ticks(0); 
00378:  CLRF   xE3
0037A:  CLRF   xE2
0037C:  MOVLB  0
0037E:  RCALL  0328
00380:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Handles a timeout when waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_timeout_now(void) 
.................... { 
....................    if((modbus_serial_state == MODBUS_GETDATA) && (modbus_serial_crc.d == 0x0000) && (!modbus_serial_new)) 
*
00E90:  MOVF   x6F,W
00E92:  SUBLW  02
00E94:  BNZ   0EAA
00E96:  MOVF   x70,F
00E98:  BNZ   0EAA
00E9A:  MOVF   x71,F
00E9C:  BNZ   0EAA
00E9E:  BTFSC  29.0
00EA0:  BRA    0EAA
....................    { 
....................       modbus_rx.len-=2; 
00EA2:  MOVLW  02
00EA4:  SUBWF  2B,F
....................       modbus_serial_new=TRUE; 
00EA6:  BSF    29.0
....................    } else { 
00EA8:  BRA    0EAC
....................       modbus_serial_new=FALSE; 
00EAA:  BCF    29.0
....................    } 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00EAC:  SETF   x71
00EAE:  SETF   x70
....................    modbus_serial_state=MODBUS_GETADDY; 
00EB0:  CLRF   x6F
00EB2:  CLRF   1B
00EB4:  BTFSC  FF2.7
00EB6:  BSF    1B.7
00EB8:  BCF    FF2.7
....................    modbus_enable_timeout(FALSE); 
00EBA:  MOVLB  1
00EBC:  CLRF   xE1
00EBE:  MOVLB  0
00EC0:  CALL   0370
00EC4:  BTFSC  1B.7
00EC6:  BSF    FF2.7
00EC8:  GOTO   0EF0 (RETURN)
.................... } 
....................  
.................... // Purpose:    Check if we have timed out waiting for a response 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... // Not used for ASCII mode 
.................... void modbus_check_timeout(void) 
.................... { 
....................    #if (MODBUS_TIMER_UPDATE == MODBUS_TIMER_NOISR) 
....................    //get_ticks() must be called more often than the timer overflow 
....................    //rate, and the get_ticks() below will not always be called 
....................    //due to short circuit evaluation 
....................    get_ticks(); 
....................    #endif 
....................    //modbus_timeout_enabled must be checked before get_ticks() 
....................    //so that if an interrupt happens it cannot be enabled after 
....................    //an old timer value is used in comparison 
....................    if(modbus_timeout_enabled && (get_ticks() > MODBUS_GETDATA_TIMEOUT)) 
00ECC:  BTFSS  29.1
00ECE:  BRA    0EF0
00ED0:  BRA    0E36
00ED2:  MOVFF  01,1B6
00ED6:  MOVFF  00,1B5
00EDA:  MOVLB  1
00EDC:  MOVF   xB6,F
00EDE:  BNZ   0EEC
00EE0:  MOVF   xB5,W
00EE2:  SUBLW  28
00EE4:  BTFSS  FD8.0
00EE6:  BRA    0EEC
00EE8:  MOVLB  0
00EEA:  BRA    0EF0
....................    { 
....................      modbus_timeout_now(); 
00EEC:  MOVLB  0
00EEE:  BRA    0E90
....................    } 
00EF0:  GOTO   0EF6 (RETURN)
.................... } 
....................  
.................... // Purpose:    Calculate crc of data and updates global crc 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_calc_crc(char data) 
.................... { 
....................    unsigned int8 uIndex ; // will index into CRC lookup table 
....................  
....................    uIndex = (modbus_serial_crc.b[1]) ^ data; // calculate the CRC 
*
00382:  MOVF   x71,W
00384:  MOVLB  1
00386:  XORWF  xE1,W
00388:  MOVWF  xE2
....................    modbus_serial_crc.b[1] = (modbus_serial_crc.b[0]) ^ modbus_auchCRCHi[uIndex]; 
0038A:  CLRF   03
0038C:  MOVF   xE2,W
0038E:  MOVLB  0
00390:  RCALL  00D8
00392:  MOVWF  01
00394:  MOVF   x70,W
00396:  XORWF  01,W
00398:  MOVWF  x71
....................    modbus_serial_crc.b[0] = modbus_auchCRCLo[uIndex]; 
0039A:  CLRF   03
0039C:  MOVLB  1
0039E:  MOVF   xE2,W
003A0:  MOVLB  0
003A2:  RCALL  01EC
003A4:  MOVWF  x70
003A6:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Puts a character onto the serial line 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_putc(unsigned int8 c) 
.................... { 
....................    fputc(c, MODBUS_SERIAL); 
*
00F38:  MOVFF  1C5,1C6
00F3C:  BRA    0F18
00F3E:  CLRF   1B
00F40:  BTFSC  FF2.7
00F42:  BSF    1B.7
00F44:  BCF    FF2.7
....................    modbus_calc_crc(c); 
00F46:  MOVFF  1C5,1E1
00F4A:  CALL   0382
00F4E:  BTFSC  1B.7
00F50:  BSF    FF2.7
....................    delay_us(1000000/MODBUS_SERIAL_BAUD); //one stop bit.  not exact 
00F52:  MOVLW  0D
00F54:  MOVWF  00
00F56:  DECFSZ 00,F
00F58:  BRA    0F56
00F5A:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Send a message over the RS485 bus 
.................... // Inputs:     1) The destination address 
.................... //             2) The number of bytes of data to send 
.................... //             3) A pointer to the data to send 
.................... //             4) The length of the data 
.................... // Outputs:    TRUE if successful 
.................... //             FALSE if failed 
.................... // Note:       Format:  source | destination | data-length | data | checksum 
.................... void modbus_serial_send_start(unsigned int8 to, unsigned int8 func) 
.................... { 
....................    modbus_serial_crc.d=0xFFFF; 
00F5C:  SETF   x71
00F5E:  SETF   x70
....................    modbus_serial_new=FALSE; 
00F60:  BCF    29.0
....................  
....................    RCV_OFF(); 
00F62:  MOVLB  E
00F64:  BCF    x2D.5
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_high(MODBUS_SERIAL_ENABLE_PIN); 
00F66:  BCF    F85.6
00F68:  BSF    F7D.6
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
00F6A:  MOVLW  31
00F6C:  MOVWF  00
00F6E:  DECFSZ 00,F
00F70:  BRA    0F6E
00F72:  BRA    0F74
....................  
....................    modbus_serial_putc(to); 
00F74:  MOVFF  1C3,1C5
00F78:  MOVLB  0
00F7A:  RCALL  0F38
....................    modbus_serial_putc(func); 
00F7C:  MOVFF  1C4,1C5
00F80:  RCALL  0F38
00F82:  RETURN 0
.................... } 
....................  
.................... // Purpose:    Ends a message over the RS485 Bus 
.................... // Inputs:     Character 
.................... // Outputs:    None 
.................... void modbus_serial_send_stop() 
.................... { 
....................    unsigned int8 crc_low, crc_high; 
....................  
....................    crc_high=modbus_serial_crc.b[1]; 
00F84:  MOVFF  71,1C4
....................    crc_low=modbus_serial_crc.b[0]; 
00F88:  MOVFF  70,1C3
....................  
....................    modbus_serial_putc(crc_high); 
00F8C:  MOVFF  1C4,1C5
00F90:  RCALL  0F38
....................    modbus_serial_putc(crc_low); 
00F92:  MOVFF  1C3,1C5
00F96:  RCALL  0F38
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE!=MODBUS_INT_EXT) 
....................    WAIT_FOR_HW_BUFFER(); 
00F98:  MOVLB  E
00F9A:  BTFSS  xE1.1
00F9C:  BRA    0F9A
.................... #endif 
....................  
....................    delay_us(3500000/MODBUS_SERIAL_BAUD); //3.5 character delay 
00F9E:  MOVLW  31
00FA0:  MOVWF  00
00FA2:  DECFSZ 00,F
00FA4:  BRA    0FA2
00FA6:  BRA    0FA8
....................  
....................    RCV_ON(); 
00FA8:  MOVLB  0
00FAA:  CALL   04FC
....................  
.................... #if (MODBUS_SERIAL_ENABLE_PIN!=0) 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
00FAE:  BCF    F85.6
00FB0:  BCF    F7D.6
.................... #endif 
....................  
....................    modbus_serial_crc.d=0xFFFF; 
00FB2:  SETF   x71
00FB4:  SETF   x70
00FB6:  RETURN 0
.................... } 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Interrupts                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #if (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA) 
.................... #int_rda 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA2) 
.................... #int_rda2 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA3) 
.................... #int_rda3 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA4) 
.................... #int_rda4 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_RDA5) 
.................... #int_rda5 
.................... #elif (MODBUS_SERIAL_INT_SOURCE==MODBUS_INT_EXT) 
.................... #if defined(__PCD__) 
.................... #int_ext1 
.................... #else 
.................... #int_ext 
.................... #endif 
.................... #else 
.................... #error Please define a correct interrupt source 
.................... #endif 
.................... void incomming_modbus_serial() { 
*
003A8:  MOVLB  0
....................    char c; 
....................  
....................    c=fgetc(MODBUS_SERIAL); 
003AA:  RCALL  030E
003AC:  MOVFF  01,1E0
....................  
....................    if (!modbus_serial_new) 
003B0:  BTFSC  29.0
003B2:  BRA    0408
....................    { 
....................       if(modbus_serial_state == MODBUS_GETADDY) 
003B4:  MOVF   x6F,F
003B6:  BNZ   03C8
....................       { 
....................          modbus_serial_crc.d = 0xFFFF; 
003B8:  SETF   x71
003BA:  SETF   x70
....................          modbus_rx.address = c; 
003BC:  MOVFF  1E0,2A
....................          modbus_serial_state++; 
003C0:  INCF   x6F,F
....................          modbus_rx.len = 0; 
003C2:  CLRF   2B
....................          modbus_rx.error=0; 
003C4:  CLRF   2D
....................       } 
003C6:  BRA    03F8
....................       else if(modbus_serial_state == MODBUS_GETFUNC) 
003C8:  DECFSZ x6F,W
003CA:  BRA    03D4
....................       { 
....................          modbus_rx.func = c; 
003CC:  MOVFF  1E0,2C
....................          modbus_serial_state++; 
003D0:  INCF   x6F,F
....................       } 
003D2:  BRA    03F8
....................       else if(modbus_serial_state == MODBUS_GETDATA) 
003D4:  MOVF   x6F,W
003D6:  SUBLW  02
003D8:  BNZ   03F8
....................       { 
....................          if (modbus_rx.len>=MODBUS_SERIAL_RX_BUFFER_SIZE) 
003DA:  MOVF   2B,W
003DC:  SUBLW  3F
003DE:  BC    03E4
....................        { 
....................          modbus_rx.len=MODBUS_SERIAL_RX_BUFFER_SIZE-1; 
003E0:  MOVLW  3F
003E2:  MOVWF  2B
....................        } 
....................          modbus_rx.data[modbus_rx.len]=c; 
003E4:  CLRF   03
003E6:  MOVF   2B,W
003E8:  ADDLW  2E
003EA:  MOVWF  FE9
003EC:  MOVLW  00
003EE:  ADDWFC 03,W
003F0:  MOVWF  FEA
003F2:  MOVFF  1E0,FEF
....................          modbus_rx.len++; 
003F6:  INCF   2B,F
....................      } 
....................      modbus_enable_timeout(TRUE); 
003F8:  MOVLW  01
003FA:  MOVLB  1
003FC:  MOVWF  xE1
003FE:  MOVLB  0
00400:  RCALL  0370
....................      modbus_calc_crc(c); 
00402:  MOVFF  1E0,1E1
00406:  RCALL  0382
....................    } 
....................  
....................    #if (MODBUS_TYPE == MODBUS_TYPE_MASTER) 
....................       modbus_serial_wait=MODBUS_SERIAL_TIMEOUT; 
....................    #endif 
.................... } 
.................... #endif //MODBUS_PHY_LAYER_RTU_C 
....................  
....................  #elif (MODBUS_SERIAL_TYPE == MODBUS_ASCII) 
....................   #include "modbus_phy_layer_ascii.c" 
....................  #endif 
.................... #else 
....................  #include "modbus_phy_layer_tcpip.c" 
.................... #endif 
....................  
.................... #if (MODBUS_PROTOCOL == MODBUS_PROTOCOL_TCPIP) 
....................  #include "modbus_app_layer_tcpip.c" 
.................... #else 
....................  #include "modbus_app_layer.c" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.c                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MODBUS_APP_LAYER_C 
.................... #define MODBUS_APP_LAYER_C 
....................  
.................... #include "modbus_app_layer.h" 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                modbus_app_layer.h                                //// 
.................... ////                                                                                  //// 
.................... ////    Application layer of the MODBUS protocol driver for serial communications.    //// 
.................... ////                                                                                  //// 
.................... ////  Refer to documentation at http://www.modbus.org for more information on MODBUS. //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                                  //// 
.................... //// Revision history:                                                                //// 
.................... ////  July 20, 2011       Seperated App Layer functions into this file from modbus.c  //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... ////                (C) Copyright 1996, 2013 Custom Computer Services                 //// 
.................... ////        This source code may only be used by licensed users of the CCS            //// 
.................... ////        C compiler.  This source code may only be distributed to other            //// 
.................... ////        licensed users of the CCS C compiler.  No other use,                      //// 
.................... ////        reproduction or distribution is permitted without written                 //// 
.................... ////        permission.  Derivative programs created using this software              //// 
.................... ////        in object code form are not restricted in any way.                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
00408:  MOVLB  E
0040A:  BCF    x37.5
0040C:  MOVLB  0
0040E:  GOTO   0082
.................... #ifndef MODBUS_APP_LAYER_H 
.................... #define MODBUS_APP_LAYER_H 
....................  
.................... #include "modbus_phy_layer.h" 
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared API                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  modbus_init()                                                                   //// 
.................... ////    - Initialize modbus serial communication system                               //// 
.................... ////                                                                                  //// 
.................... ////  modbus_kbhit()                                                                  //// 
.................... ////    - Used to check if a packet has been received.                                //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init(); 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit(); 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master Api                                                                       //// 
.................... ////                                                                                  //// 
.................... ////  All master API functions return 0 on success.                                   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_coils(address,start_address,quantity)                     //// 
.................... ////    - Wrapper for function 0x01(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_discrete_input(address,start_address,quantity)            //// 
.................... ////    - Wrapper for function 0x02(read discret input) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_holding_registers(address,start_address,quantity)         //// 
.................... ////    - Wrapper for function 0x03(read holding regs) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_input_registers(address,start_address,quantity)           //// 
.................... ////    - Wrapper for function 0x04(read input regs) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_coil(address,output_address,on)                   //// 
.................... ////    - Wrapper for function 0x05(write single coil) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_single_register(address,reg_address,reg_value)           //// 
.................... ////    - Wrapper for function 0x06(write single reg) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_exception_status(address)                                 //// 
.................... ////    - Wrapper for function 0x07(read void status) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_diagnostics(address,sub_func,data)                             //// 
.................... ////    - Wrapper for function 0x08(diagnostics) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_counter(address)                                //// 
.................... ////    - Wrapper for function 0x0B(get comm event count) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_get_comm_event_log(address)                                    //// 
.................... ////    - Wrapper for function 0x0C(get comm event log) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_coils(address,start_address,quantity,*values)   //// 
.................... ////    - Wrapper for function 0x0F(write multiple coils) in the MODBUS specification.//// 
.................... ////    - Special Note: values is a pointer to an int8 array, each byte represents 8  //// 
.................... ////                    coils.                                                        //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_multiple_registers(address,start_address,quantity,*values)/// 
.................... ////    - Wrapper for function 0x10(write multiple regs) in the MODBUS specification. //// 
.................... ////    - Special Note: values is a pointer to an int8 array                          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_report_slave_id(address)                                       //// 
.................... ////    - Wrapper for function 0x11(report slave id) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_file_record(address,byte_count,*request)                  //// 
.................... ////    - Wrapper for function 0x14(read file record) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_write_file_record(address,byte_count,*request)                 //// 
.................... ////    - Wrapper for function 0x15(write file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_mask_write_register(address,reference_address,AND_mask,OR_mask)//// 
.................... ////    - Wrapper for function 0x16(read coils) in the MODBUS specification.          //// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_write_multiple_registers(address,read_start,read_quantity,//// 
.................... ////                            write_start,write_quantity, *write_registers_value)   //// 
.................... ////    - Wrapper for function 0x17(read write mult regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  exception modbus_read_FIFO_queue(address,FIFO_address)                          //// 
.................... ////    - Wrapper for function 0x18(read FIFO queue) in the MODBUS specification.     //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request.  These 
.................... functions take in one of these structs. 
.................... Please refer to the MODBUS protocol specification if you do not 
.................... understand the members of the structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
.................... } modbus_read_sub_request; 
....................  
.................... typedef struct _modbus_write_sub_request 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[MODBUS_SERIAL_RX_BUFFER_SIZE-8]; 
.................... } modbus_write_sub_request; 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity); 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on); 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address); 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address); 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address); 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values); 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values); 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address); 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request); 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request); 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value); 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address); 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_coils_rsp(address,byte_count,*coil_data)                       //// 
.................... ////    - Wrapper to respond to 0x01(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_discrete_input_rsp(address,byte_count,*input_data)             //// 
.................... ////    - Wrapper to respond to 0x02(read discret input) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_holding_registers_rsp(address,byte_count,*reg_data)            //// 
.................... ////    - Wrapper to respond to 0x03(read holding regs) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_input_registers_rsp(address,byte_count,*input_data)            //// 
.................... ////    - Wrapper to respond to 0x04(read input regs) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_coil_rsp(address,output_address,output_value)          //// 
.................... ////    - Wrapper to respond to 0x05(write single coil) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_single_register_rsp(address,reg_address,reg_value)            //// 
.................... ////    - Wrapper to respond to 0x06(write single reg) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_exception_status_rsp(address, data)                            //// 
.................... ////    - Wrapper to respond to 0x07(read void status) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_diagnostics_rsp(address,sub_func,data)                              //// 
.................... ////    - Wrapper to respond to 0x08(diagnostics) in the MODBUS specification.        //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_counter_rsp(address,status,event_count)              //// 
.................... ////    - Wrapper to respond to 0x0B(get comm event count) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_get_comm_event_log_rsp(address,status,event_count,message_count,    //// 
.................... ////                                   *events, events_len)                           //// 
.................... ////    - Wrapper to respond to 0x0C(get comm event log) in the MODBUS specification. //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_coils_rsp(address,start_address,quantity)            //// 
.................... ////    - Wrapper to respond to 0x0F(write multiple coils) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_multiple_registers_rsp(address,start_address,quantity)        //// 
.................... ////    - Wrapper to respond to 0x10(write multiple regs) in the MODBUS specification.//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_report_slave_id_rsp(address,slave_id,run_status,*data,data_len)     //// 
.................... ////    - Wrapper to respond to 0x11(report slave id) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_file_record_rsp(address,byte_count,*request)                   //// 
.................... ////    - Wrapper to respond to 0x14(read file record) in the MODBUS specification.   //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_write_file_record_rsp(address,byte_count,*request)                  //// 
.................... ////    - Wrapper to respond to 0x15(write file record) in the MODBUS specification.  //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_mask_write_register_rsp(address,reference_address,AND_mask,OR_mask) //// 
.................... ////    - Wrapper to respond to 0x16(read coils) in the MODBUS specification.         //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_write_multiple_registers_rsp(address,*data,data_len)           //// 
.................... ////    - Wrapper to respond to 0x17(read write mult regs) in the MODBUS specification//// 
.................... ////                                                                                  //// 
.................... ////  void modbus_read_FIFO_queue_rsp(address,FIFO_len,*data)                         //// 
.................... ////    - Wrapper to respond to 0x18(read FIFO queue) in the MODBUS specification.    //// 
.................... ////                                                                                  //// 
.................... ////  void modbus_exception_rsp(int8 address, int16 func, exception error)            //// 
.................... ////    - Wrapper to send an exception response.  See exception list below.           //// 
.................... ////                                                                                  //// 
.................... //// Exception List:                                                                  //// 
.................... ////  ILLEGAL_FUNCTION, ILLEGAL_DATA_ADDRESS, ILLEGAL_DATA_VALUE,                     //// 
.................... ////  SLAVE_DEVICE_FAILURE, ACKNOWLEDGE, SLAVE_DEVICE_BUSY, MEMORY_PARITY_ERROR,      //// 
.................... ////  GATEWAY_PATH_UNAVAILABLE, GATEWAY_TARGET_NO_RESPONSE                            //// 
.................... ////                                                                                  //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following structs are used for read/write_sub_request_rsp.  These 
.................... functions take in one of these structs.  Please refer to the MODBUS 
.................... protocol specification if you do not understand the members of the 
.................... structure. 
.................... ********************************************************************/ 
.................... typedef struct _modbus_read_sub_request_rsp 
.................... { 
....................    unsigned int8 record_length; 
....................    unsigned int8 reference_type; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-3]; 
.................... } modbus_read_sub_request_rsp; 
....................  
.................... typedef struct _modbus_write_sub_request_rsp 
.................... { 
....................    unsigned int8 reference_type; 
....................    unsigned int16 file_number; 
....................    unsigned int16 record_number; 
....................    unsigned int16 record_length; 
....................    unsigned int16 data[((MODBUS_SERIAL_RX_BUFFER_SIZE)/2)-8]; 
.................... } modbus_write_sub_request_rsp; 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data); 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data); 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data); 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data); 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value); 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value); 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data); 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data); 
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count); 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len); 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity); 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity); 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len); 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request); 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request); 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask); 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data); 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data); 
....................  
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error); 
.................... #endif //MODBUS_TYPE 
....................  
.................... #endif //MODBUS_APP_LAYER_H 
....................  
....................  
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Shared Api                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... // Purpose:    Initialize RS485 communication. Call this before 
.................... //             using any other RS485 functions. 
.................... // Inputs:     None 
.................... // Outputs:    None 
.................... void modbus_init() 
.................... { 
....................    output_low(MODBUS_SERIAL_ENABLE_PIN); 
*
00516:  BCF    F85.6
00518:  BCF    F7D.6
....................  
....................    RCV_ON(); 
0051A:  RCALL  04FC
....................  
....................    #if defined(__PCD__) 
....................       enable_interrupts(INTR_GLOBAL); 
....................    #else 
....................       enable_interrupts(GLOBAL); 
0051C:  MOVLW  C0
0051E:  IORWF  FF2,F
....................    #endif 
00520:  GOTO   18A8 (RETURN)
.................... } 
....................  
.................... // Purpose:    Get a message from the RS485 bus and store it in a buffer 
.................... // Inputs:     None 
.................... // Outputs:    TRUE if a message was received 
.................... //             FALSE if no message is available 
.................... // Note:       Data will be filled in at the modbus_rx struct: 
.................... int1 modbus_kbhit() 
.................... { 
....................    #if(MODBUS_SERIAL_TYPE == MODBUS_RTU) 
....................    modbus_check_timeout(); 
*
00EF4:  BRA    0ECC
....................    #endif 
....................  
....................    if(!modbus_serial_new) 
00EF6:  BTFSC  29.0
00EF8:  BRA    0F02
....................      return FALSE; 
00EFA:  MOVLW  00
00EFC:  MOVWF  01
00EFE:  BRA    0F14
00F00:  BRA    0F0E
....................    else if(modbus_rx.func & 0x80)           //did we receive an error? 
00F02:  BTFSS  2C.7
00F04:  BRA    0F0E
....................    { 
....................       modbus_rx.error = modbus_rx.data[0];  //if so grab the error and return true 
00F06:  MOVFF  2E,2D
....................       modbus_rx.len = 1; 
00F0A:  MOVLW  01
00F0C:  MOVWF  2B
....................    } 
....................    modbus_serial_new=FALSE; 
00F0E:  BCF    29.0
....................    return TRUE; 
00F10:  MOVLW  01
00F12:  MOVWF  01
00F14:  GOTO   190E (RETURN)
.................... } 
....................  
.................... #if (MODBUS_TYPE==MODBUS_TYPE_MASTER) 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Master API                                                                       //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following functions are defined in the MODBUS protocol.  Please 
.................... refer to http://www.modbus.org for the purpose of each of these. 
.................... All functions take the slaves address as their first parameter. 
.................... Each function returns the exception code received from the response. 
.................... The function will return 0 if there were no errors in transmission. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_discrete_input 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_discrete_input(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_holding_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_holding_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_input_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start reading from 
....................            int16      quantity           Amount of addresses to read 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_input_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_coil 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Address to write into 
....................            int1       on                 true for on, false for off 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_coil(unsigned int8 address, unsigned int16 output_address, int1 on) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
....................    modbus_serial_putc(make8(output_address,0)); 
....................  
....................    if(on) 
....................        modbus_serial_putc(0xFF); 
....................    else 
....................        modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_putc(0x00); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_single_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Address to write into 
....................            int16      reg_value          Value to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_single_register(unsigned int8 address, unsigned int16 reg_address, unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
....................    modbus_serial_putc(make8(reg_address,0)); 
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
....................    modbus_serial_putc(make8(reg_value,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_exception_status 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_exception_status(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... diagnostics 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Subfunction to send 
....................            int16      data               Data to send, changes based on subfunction 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_diagnostics(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_couter 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_counter(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... get_comm_event_log 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_get_comm_event_log(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int1*      values             A pointer to an array holding the values to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_coils(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int8 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = (unsigned int8)((quantity/8)); 
....................  
....................    if(quantity%8) 
....................       count++; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < count; ++i) 
....................       modbus_serial_putc(values[i]); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_multiple_registers 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Address to start at 
....................            int16      quantity           Amount of coils to write to 
....................            int16*     values             A pointer to an array holding the data to write 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_multiple_registers(unsigned int8 address, unsigned int16 start_address, unsigned int16 quantity, 
....................                            unsigned int16 *values) 
.................... { 
....................    unsigned int8 i,count; 
....................  
....................    count = quantity*2; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
....................    modbus_serial_putc(make8(start_address,0)); 
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
....................    modbus_serial_putc(make8(quantity,0)); 
....................  
....................    modbus_serial_putc(count); 
....................  
....................    for(i=0; i < quantity; ++i) 
....................    { 
....................       modbus_serial_putc(make8(values[i],1)); 
....................       modbus_serial_putc(make8(values[i],0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... report_slave_id 
.................... Input:     int8       address            Slave Address 
.................... Output:    exception                     0 if no error, else the exception 
.................... */ 
.................... exception modbus_report_slave_id(unsigned int8 address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_read_sub_request *request) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < (byte_count/7); i+=7) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... write_file_record 
.................... Input:     int8                address            Slave Address 
....................            int8                byte_count         Number of bytes to read 
....................            read_sub_request*   request            Structure holding record/data information 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_write_file_record(unsigned int8 address, unsigned int8 byte_count, 
....................                             modbus_write_sub_request *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length) && 
....................             (j < MODBUS_SERIAL_RX_BUFFER_SIZE-8); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... mask_write_register 
.................... Input:     int8       address            Slave Address 
....................            int16      reference_address  Address to mask 
....................            int16      AND_mask           A mask to AND with the data at reference_address 
....................            int16      OR_mask            A mask to OR with the data at reference_address 
.................... Output:    exception                              0 if no error, else the exception 
.................... */ 
.................... exception modbus_mask_write_register(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers 
.................... Input:     int8       address                Slave Address 
....................            int16      read_start             Address to start reading 
....................            int16      read_quantity          Amount of registers to read 
....................            int16      write_start            Address to start writing 
....................            int16      write_quantity         Amount of registers to write 
....................            int16*     write_registers_value  Pointer to an aray us to write 
.................... Output:    exception                         0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_write_multiple_registers(unsigned int8 address, unsigned int16 read_start, 
....................                                     unsigned int16 read_quantity, unsigned int16 write_start, 
....................                                     unsigned int16 write_quantity, 
....................                                     unsigned int16 *write_registers_value) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(make8(read_start,1)); 
....................    modbus_serial_putc(make8(read_start,0)); 
....................  
....................    modbus_serial_putc(make8(read_quantity,1)); 
....................    modbus_serial_putc(make8(read_quantity,0)); 
....................  
....................    modbus_serial_putc(make8(write_start, 1)); 
....................    modbus_serial_putc(make8(write_start, 0)); 
....................  
....................    modbus_serial_putc(make8(write_quantity, 1)); 
....................    modbus_serial_putc(make8(write_quantity, 0)); 
....................  
....................    modbus_serial_putc((unsigned int8)(2*write_quantity)); 
....................  
....................    for(i=0; i < write_quantity ; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(write_registers_value[i], 1)); 
....................       modbus_serial_putc(make8(write_registers_value[i+1], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue 
.................... Input:     int8       address           Slave Address 
....................            int16      FIFO_address      FIFO address 
.................... Output:    exception                    0 if no error, else the exception 
.................... */ 
.................... exception modbus_read_FIFO_queue(unsigned int8 address, unsigned int16 FIFO_address) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(FIFO_address, 1)); 
....................    modbus_serial_putc(make8(FIFO_address, 0)); 
....................  
....................    modbus_serial_send_stop(); 
....................  
....................    MODBUS_SERIAL_WAIT_FOR_RESPONSE(); 
....................  
....................    return modbus_rx.error; 
.................... } 
....................  
.................... #else 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
.................... //// Slave API                                                                        //// 
.................... ////////////////////////////////////////////////////////////////////////////////////////// 
....................  
.................... /******************************************************************** 
.................... The following slave functions are defined in the MODBUS protocol. 
.................... Please refer to http://www.modbus.org for the purpose of each of 
.................... these.  All functions take the slaves address as their first 
.................... parameter. 
.................... ********************************************************************/ 
....................  
.................... /* 
.................... read_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      coil_data          Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_coils_rsp(unsigned int8 address, unsigned int8 byte_count, unsigned int8* coil_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_COILS); 
*
00FD8:  MOVFF  1BA,1C3
00FDC:  MOVLW  01
00FDE:  MOVLB  1
00FE0:  MOVWF  xC4
00FE2:  MOVLB  0
00FE4:  RCALL  0F5C
....................  
....................    modbus_serial_putc(byte_count); 
00FE6:  MOVFF  1BB,1C5
00FEA:  RCALL  0F38
....................  
....................    for(i=0; i < byte_count; ++i) 
00FEC:  MOVLB  1
00FEE:  CLRF   xBE
00FF0:  MOVF   xBB,W
00FF2:  SUBWF  xBE,W
00FF4:  BC    1016
....................    { 
....................       modbus_serial_putc(*coil_data); 
00FF6:  MOVFF  1BD,03
00FFA:  MOVFF  1BC,FE9
00FFE:  MOVFF  03,FEA
01002:  MOVFF  FEF,1C5
01006:  MOVLB  0
01008:  RCALL  0F38
....................       coil_data++; 
0100A:  MOVLB  1
0100C:  INCF   xBC,F
0100E:  BTFSC  FD8.2
01010:  INCF   xBD,F
01012:  INCF   xBE,F
01014:  BRA    0FF0
....................    } 
....................  
....................    modbus_serial_send_stop(); 
01016:  MOVLB  0
01018:  RCALL  0F84
0101A:  GOTO   13A8 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_discrete_input_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_discrete_input_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     unsigned int8 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_DISCRETE_INPUT); 
0101E:  MOVFF  1BA,1C3
01022:  MOVLW  02
01024:  MOVLB  1
01026:  MOVWF  xC4
01028:  MOVLB  0
0102A:  RCALL  0F5C
....................  
....................    modbus_serial_putc(byte_count); 
0102C:  MOVFF  1BB,1C5
01030:  RCALL  0F38
....................  
....................    for(i=0; i < byte_count; ++i) 
01032:  MOVLB  1
01034:  CLRF   xBE
01036:  MOVF   xBB,W
01038:  SUBWF  xBE,W
0103A:  BC    105C
....................    { 
....................       modbus_serial_putc(*input_data); 
0103C:  MOVFF  1BD,03
01040:  MOVFF  1BC,FE9
01044:  MOVFF  03,FEA
01048:  MOVFF  FEF,1C5
0104C:  MOVLB  0
0104E:  RCALL  0F38
....................       input_data++; 
01050:  MOVLB  1
01052:  INCF   xBC,F
01054:  BTFSC  FD8.2
01056:  INCF   xBD,F
01058:  INCF   xBE,F
0105A:  BRA    1036
....................    } 
....................  
....................    modbus_serial_send_stop(); 
0105C:  MOVLB  0
0105E:  RCALL  0F84
01060:  GOTO   13A8 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_holding_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      reg_data           Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_holding_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *reg_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_HOLDING_REGISTERS); 
01064:  MOVFF  1BD,1C3
01068:  MOVLW  03
0106A:  MOVLB  1
0106C:  MOVWF  xC4
0106E:  MOVLB  0
01070:  RCALL  0F5C
....................  
....................    modbus_serial_putc(byte_count); 
01072:  MOVFF  1BE,1C5
01076:  RCALL  0F38
....................  
....................    for(i=0; i < byte_count; i+=2) 
01078:  MOVLB  1
0107A:  CLRF   xC1
0107C:  MOVF   xBE,W
0107E:  SUBWF  xC1,W
01080:  BC    10D8
....................    { 
....................       modbus_serial_putc(make8(*reg_data,1)); 
01082:  MOVFF  1C0,03
01086:  MOVFF  1BF,FE9
0108A:  MOVFF  03,FEA
0108E:  MOVFF  FEC,1C3
01092:  MOVF   FED,F
01094:  MOVFF  FEF,1C2
01098:  MOVFF  1C3,1C4
0109C:  MOVFF  1C3,1C5
010A0:  MOVLB  0
010A2:  RCALL  0F38
....................       modbus_serial_putc(make8(*reg_data,0)); 
010A4:  MOVFF  1C0,03
010A8:  MOVLB  1
010AA:  MOVFF  1BF,FE9
010AE:  MOVFF  03,FEA
010B2:  MOVFF  FEC,1C3
010B6:  MOVF   FED,F
010B8:  MOVFF  FEF,1C2
010BC:  MOVFF  1C2,1C4
010C0:  MOVFF  1C2,1C5
010C4:  MOVLB  0
010C6:  RCALL  0F38
....................       reg_data++; 
010C8:  MOVLW  02
010CA:  MOVLB  1
010CC:  ADDWF  xBF,F
010CE:  BTFSC  FD8.0
010D0:  INCF   xC0,F
010D2:  MOVLW  02
010D4:  ADDWF  xC1,F
010D6:  BRA    107C
....................    } 
....................  
....................    modbus_serial_send_stop(); 
010D8:  MOVLB  0
010DA:  RCALL  0F84
010DC:  GOTO   1412 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_input_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       byte_count         Number of bytes being sent 
....................            int8*      input_data         Pointer to an array of data to send 
.................... Output:    void 
.................... */ 
.................... void modbus_read_input_registers_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                         unsigned int16 *input_data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_INPUT_REGISTERS); 
010E0:  MOVFF  1BD,1C3
010E4:  MOVLW  04
010E6:  MOVLB  1
010E8:  MOVWF  xC4
010EA:  MOVLB  0
010EC:  RCALL  0F5C
....................  
....................    modbus_serial_putc(byte_count); 
010EE:  MOVFF  1BE,1C5
010F2:  RCALL  0F38
....................  
....................    for(i=0; i < byte_count; i+=2) 
010F4:  MOVLB  1
010F6:  CLRF   xC1
010F8:  MOVF   xBE,W
010FA:  SUBWF  xC1,W
010FC:  BC    1154
....................    { 
....................       modbus_serial_putc(make8(*input_data,1)); 
010FE:  MOVFF  1C0,03
01102:  MOVFF  1BF,FE9
01106:  MOVFF  03,FEA
0110A:  MOVFF  FEC,1C3
0110E:  MOVF   FED,F
01110:  MOVFF  FEF,1C2
01114:  MOVFF  1C3,1C4
01118:  MOVFF  1C3,1C5
0111C:  MOVLB  0
0111E:  RCALL  0F38
....................       modbus_serial_putc(make8(*input_data,0)); 
01120:  MOVFF  1C0,03
01124:  MOVLB  1
01126:  MOVFF  1BF,FE9
0112A:  MOVFF  03,FEA
0112E:  MOVFF  FEC,1C3
01132:  MOVF   FED,F
01134:  MOVFF  FEF,1C2
01138:  MOVFF  1C2,1C4
0113C:  MOVFF  1C2,1C5
01140:  MOVLB  0
01142:  RCALL  0F38
....................       input_data++; 
01144:  MOVLW  02
01146:  MOVLB  1
01148:  ADDWF  xBF,F
0114A:  BTFSC  FD8.0
0114C:  INCF   xC0,F
0114E:  MOVLW  02
01150:  ADDWF  xC1,F
01152:  BRA    10F8
....................    } 
....................  
....................    modbus_serial_send_stop(); 
01154:  MOVLB  0
01156:  RCALL  0F84
01158:  GOTO   1440 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_single_coil_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      output_address     Echo of output address received 
....................            int16      output_value       Echo of output value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_coil_rsp(unsigned int8 address, unsigned int16 output_address, 
....................                                     unsigned int16 output_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_COIL); 
0115C:  MOVFF  1BC,1C3
01160:  MOVLW  05
01162:  MOVLB  1
01164:  MOVWF  xC4
01166:  MOVLB  0
01168:  RCALL  0F5C
....................  
....................    modbus_serial_putc(make8(output_address,1)); 
0116A:  MOVFF  1BE,1C1
0116E:  MOVFF  1BE,1C5
01172:  RCALL  0F38
....................    modbus_serial_putc(make8(output_address,0)); 
01174:  MOVFF  1BD,1C1
01178:  MOVFF  1BD,1C5
0117C:  RCALL  0F38
....................  
....................    modbus_serial_putc(make8(output_value,1)); 
0117E:  MOVFF  1C0,1C1
01182:  MOVFF  1C0,1C5
01186:  RCALL  0F38
....................    modbus_serial_putc(make8(output_value,0)); 
01188:  MOVFF  1BF,1C1
0118C:  MOVFF  1BF,1C5
01190:  RCALL  0F38
....................  
....................    modbus_serial_send_stop(); 
01192:  RCALL  0F84
01194:  GOTO   14E8 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_single_register_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      reg_address        Echo of register address received 
....................            int16      reg_value          Echo of register value received 
.................... Output:    void 
.................... */ 
.................... void modbus_write_single_register_rsp(unsigned int8 address, unsigned int16 reg_address, 
....................                                         unsigned int16 reg_value) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_SINGLE_REGISTER); 
01198:  MOVFF  1BE,1C3
0119C:  MOVLW  06
0119E:  MOVLB  1
011A0:  MOVWF  xC4
011A2:  MOVLB  0
011A4:  RCALL  0F5C
....................  
....................    modbus_serial_putc(make8(reg_address,1)); 
011A6:  MOVFF  1C0,1C3
011AA:  MOVFF  1C0,1C5
011AE:  RCALL  0F38
....................    modbus_serial_putc(make8(reg_address,0)); 
011B0:  MOVFF  1BF,1C3
011B4:  MOVFF  1BF,1C5
011B8:  RCALL  0F38
....................  
....................    modbus_serial_putc(make8(reg_value,1)); 
011BA:  MOVFF  1C2,1C3
011BE:  MOVFF  1C2,1C5
011C2:  RCALL  0F38
....................    modbus_serial_putc(make8(reg_value,0)); 
011C4:  MOVFF  1C1,1C3
011C8:  MOVFF  1C1,1C5
011CC:  RCALL  0F38
....................  
....................    modbus_serial_send_stop(); 
011CE:  RCALL  0F84
011D0:  GOTO   1558 (RETURN)
.................... } 
....................  
.................... /* 
.................... read_exception_status_rsp 
.................... Input:     int8       address            Slave Address 
.................... Output:    void 
.................... */ 
.................... void modbus_read_exception_status_rsp(unsigned int8 address, unsigned int8 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_READ_EXCEPTION_STATUS); 
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... diagnostics_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      sub_func           Echo of sub function received 
....................            int16      data               Echo of data received 
.................... Output:    void 
.................... */ 
.................... void modbus_diagnostics_rsp(unsigned int8 address, unsigned int16 sub_func, unsigned int16 data) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_DIAGNOSTICS); 
....................  
....................    modbus_serial_putc(make8(sub_func,1)); 
....................    modbus_serial_putc(make8(sub_func,0)); 
....................  
....................    modbus_serial_putc(make8(data,1)); 
....................    modbus_serial_putc(make8(data,0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_counter_rsp(unsigned int8 address, unsigned int16 status, 
....................                                         unsigned int16 event_count) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_COUNTER); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... get_comm_event_counter_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      status             Status, refer to MODBUS documentation 
....................            int16      event_count        Count of events 
....................            int16      message_count      Count of messages 
....................            int8*      events             Pointer to event data 
....................            int8       events_len         Length of event data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_get_comm_event_log_rsp(unsigned int8 address, unsigned int16 status, 
....................                                     unsigned int16 event_count, unsigned int16 message_count, 
....................                                     unsigned int8 *events, unsigned int8 events_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_GET_COMM_EVENT_LOG); 
....................  
....................    modbus_serial_putc(events_len+6); 
....................  
....................    modbus_serial_putc(make8(status, 1)); 
....................    modbus_serial_putc(make8(status, 0)); 
....................  
....................    modbus_serial_putc(make8(event_count, 1)); 
....................    modbus_serial_putc(make8(event_count, 0)); 
....................  
....................    modbus_serial_putc(make8(message_count, 1)); 
....................    modbus_serial_putc(make8(message_count, 0)); 
....................  
....................    for(i=0; i < events_len; ++i) 
....................    { 
....................       modbus_serial_putc(*events); 
....................       events++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_multiple_coils_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of coils written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_coils_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                         unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_COILS); 
*
0123E:  MOVFF  1BE,1C3
01242:  MOVLW  0F
01244:  MOVLB  1
01246:  MOVWF  xC4
01248:  MOVLB  0
0124A:  RCALL  0F5C
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
0124C:  MOVFF  1C0,1C3
01250:  MOVFF  1C0,1C5
01254:  RCALL  0F38
....................    modbus_serial_putc(make8(start_address,0)); 
01256:  MOVFF  1BF,1C3
0125A:  MOVFF  1BF,1C5
0125E:  RCALL  0F38
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
01260:  MOVFF  1C2,1C3
01264:  MOVFF  1C2,1C5
01268:  RCALL  0F38
....................    modbus_serial_putc(make8(quantity,0)); 
0126A:  MOVFF  1C1,1C3
0126E:  MOVFF  1C1,1C5
01272:  RCALL  0F38
....................  
....................    modbus_serial_send_stop(); 
01274:  RCALL  0F84
01276:  GOTO   1624 (RETURN)
.................... } 
....................  
.................... /* 
.................... write_multiple_registers_rsp 
.................... Input:     int8       address            Slave Address 
....................            int16      start_address      Echo of address to start at 
....................            int16      quantity           Echo of amount of registers written to 
.................... Output:    void 
.................... */ 
.................... void modbus_write_multiple_registers_rsp(unsigned int8 address, unsigned int16 start_address, 
....................                                             unsigned int16 quantity) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_WRITE_MULTIPLE_REGISTERS); 
0127A:  MOVFF  1BE,1C3
0127E:  MOVLW  10
01280:  MOVLB  1
01282:  MOVWF  xC4
01284:  MOVLB  0
01286:  RCALL  0F5C
....................  
....................    modbus_serial_putc(make8(start_address,1)); 
01288:  MOVFF  1C0,1C3
0128C:  MOVFF  1C0,1C5
01290:  RCALL  0F38
....................    modbus_serial_putc(make8(start_address,0)); 
01292:  MOVFF  1BF,1C3
01296:  MOVFF  1BF,1C5
0129A:  RCALL  0F38
....................  
....................    modbus_serial_putc(make8(quantity,1)); 
0129C:  MOVFF  1C2,1C3
012A0:  MOVFF  1C2,1C5
012A4:  RCALL  0F38
....................    modbus_serial_putc(make8(quantity,0)); 
012A6:  MOVFF  1C1,1C3
012AA:  MOVFF  1C1,1C5
012AE:  RCALL  0F38
....................  
....................    modbus_serial_send_stop(); 
012B0:  RCALL  0F84
012B2:  GOTO   16F2 (RETURN)
.................... } 
....................  
.................... /* 
.................... report_slave_id_rsp 
.................... Input:     int8       address            Slave Address 
....................            int8       slave_id           Slave Address 
....................            int8       run_status         Are we running? 
....................            int8*      data               Pointer to an array holding the data 
....................            int8       data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_report_slave_id_rsp(unsigned int8 address, unsigned int8 slave_id, unsigned int1 run_status, 
....................                               unsigned int8 *data, unsigned int8 data_len) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_REPORT_SLAVE_ID); 
....................  
....................    modbus_serial_putc(data_len+2); 
....................    modbus_serial_putc(slave_id); 
....................  
....................    if(run_status) 
....................     modbus_serial_putc(0xFF); 
....................    else 
....................     modbus_serial_putc(0x00); 
....................  
....................    for(i=0; i < data_len; ++i) 
....................    { 
....................       modbus_serial_putc(*data); 
....................       data++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Number of bytes to send 
....................            read_sub_request_rsp*    request            Structure holding record/data information 
.................... Output:    void 
.................... */ 
.................... void modbus_read_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_read_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i=0,j; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    while(i < byte_count); 
....................    { 
....................       modbus_serial_putc(request->record_length); 
....................       modbus_serial_putc(request->reference_type); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................  
....................       i += (request->record_length)+1; 
....................       request++; 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... write_file_record_rsp 
.................... Input:     int8                     address            Slave Address 
....................            int8                     byte_count         Echo of number of bytes sent 
....................            write_sub_request_rsp*   request            Echo of Structure holding record information 
.................... Output:    void 
.................... */ 
.................... void modbus_write_file_record_rsp(unsigned int8 address, unsigned int8 byte_count, 
....................                                     modbus_write_sub_request_rsp *request) 
.................... { 
....................    unsigned int8 i, j=0; 
....................  
....................    modbus_serial_send_start(address, FUNC_WRITE_FILE_RECORD); 
....................  
....................    modbus_serial_putc(byte_count); 
....................  
....................    for(i=0; i < byte_count; i+=(7+(j*2))) 
....................    { 
....................       modbus_serial_putc(request->reference_type); 
....................       modbus_serial_putc(make8(request->file_number, 1)); 
....................       modbus_serial_putc(make8(request->file_number, 0)); 
....................       modbus_serial_putc(make8(request->record_number, 1)); 
....................       modbus_serial_putc(make8(request->record_number, 0)); 
....................       modbus_serial_putc(make8(request->record_length, 1)); 
....................       modbus_serial_putc(make8(request->record_length, 0)); 
....................  
....................       for(j=0; (j < request->record_length); j+=2) 
....................       { 
....................          modbus_serial_putc(make8(request->data[j], 1)); 
....................          modbus_serial_putc(make8(request->data[j], 0)); 
....................       } 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... mask_write_register_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       reference_address  Echo of reference address 
....................            int16       AND_mask           Echo of AND mask 
....................            int16       OR_mask            Echo or OR mask 
.................... Output:    void 
.................... */ 
.................... void modbus_mask_write_register_rsp(unsigned int8 address, unsigned int16 reference_address, 
....................                            unsigned int16 AND_mask, unsigned int16 OR_mask) 
.................... { 
....................    modbus_serial_send_start(address, FUNC_MASK_WRITE_REGISTER); 
....................  
....................    modbus_serial_putc(make8(reference_address,1)); 
....................    modbus_serial_putc(make8(reference_address,0)); 
....................  
....................    modbus_serial_putc(make8(AND_mask,1)); 
....................    modbus_serial_putc(make8(AND_mask,0)); 
....................  
....................    modbus_serial_putc(make8(OR_mask, 1)); 
....................    modbus_serial_putc(make8(OR_mask, 0)); 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_write_multiple_registers_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16*      data               Pointer to an array of data 
....................            int8        data_len           Length of data in bytes 
.................... Output:    void 
.................... */ 
.................... void modbus_read_write_multiple_registers_rsp(unsigned int8 address, unsigned int8 data_len, 
....................                                                 unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_WRITE_MULTIPLE_REGISTERS); 
....................  
....................    modbus_serial_putc(data_len*2); 
....................  
....................    for(i=0; i < data_len*2; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       FIFO_len           Length of FIFO in bytes 
....................            int16*      data               Pointer to an array of data 
.................... Output:    void 
.................... */ 
.................... void modbus_read_FIFO_queue_rsp(unsigned int8 address, unsigned int16 FIFO_len, unsigned int16 *data) 
.................... { 
....................    unsigned int8 i; 
....................    unsigned int16 byte_count; 
....................  
....................    byte_count = ((FIFO_len*2)+2); 
....................  
....................    modbus_serial_send_start(address, FUNC_READ_FIFO_QUEUE); 
....................  
....................    modbus_serial_putc(make8(byte_count, 1)); 
....................    modbus_serial_putc(make8(byte_count, 0)); 
....................  
....................    modbus_serial_putc(make8(FIFO_len, 1)); 
....................    modbus_serial_putc(make8(FIFO_len, 0)); 
....................  
....................    for(i=0; i < FIFO_len; i+=2) 
....................    { 
....................       modbus_serial_putc(make8(data[i], 1)); 
....................       modbus_serial_putc(make8(data[i], 0)); 
....................    } 
....................  
....................    modbus_serial_send_stop(); 
.................... } 
....................  
.................... /* 
.................... read_FIFO_queue_rsp 
.................... Input:     int8        address            Slave Address 
....................            int16       func               function to respond to 
....................            exception   error              exception response to send 
.................... Output:    void 
.................... */ 
.................... void modbus_exception_rsp(unsigned int8 address, unsigned int16 func, exception error) 
.................... { 
....................    modbus_serial_send_start(address, func|0x80); 
*
00FB8:  MOVLB  1
00FBA:  MOVF   xBB,W
00FBC:  IORLW  80
00FBE:  MOVWF  xBE
00FC0:  MOVFF  1BC,1BF
00FC4:  MOVFF  1BA,1C3
00FC8:  MOVWF  xC4
00FCA:  MOVLB  0
00FCC:  RCALL  0F5C
....................    modbus_serial_putc(error); 
00FCE:  MOVFF  1BD,1C5
00FD2:  RCALL  0F38
....................    modbus_serial_send_stop(); 
00FD4:  RCALL  0F84
00FD6:  RETURN 0
.................... } 
....................  
.................... #endif 
.................... #endif //MODBUS_APP_LAYER_C 
....................  
.................... #endif 
....................  
....................  
.................... #include "devices/generic_uart.h" 
.................... /*  
....................  * File:   generic_uart.h 
....................  * Author: artga 
....................  * 
....................  * Created on 12 de enero de 2022, 12:20 PM 
....................  */ 
....................  
.................... #ifndef GENERIC_UART_H 
.................... #define	GENERIC_UART_H 
....................  
.................... #define UART_INT_RDA     	11111 
.................... #define UART_INT_RDA2		22222 
.................... #define UART_INT_RDA3    	33333 
.................... #define UART_INT_RDA4    	44444 
.................... #define UART_INT_RDA5       55555   
....................  
.................... #define BUFFER_SIZE 255 
.................... #ifndef DEVICE_DEBUG 
.................... #define DEVICE_DEBUG FALSE 
.................... #endif 
....................  
.................... struct data_uart{ 
....................     char buffer[BUFFER_SIZE]; 
....................     BOOLEAN AVAILABLE; 
....................     long len; 
....................          
.................... }data; 
.................... /*Generic functions*/ 
.................... void device_init(void); 
.................... BOOLEAN device_reset(BOOLEAN pulse, long time_ms); 
.................... void data_send(char* buffer, long len); 
.................... BOOLEAN data_timeout(long millis); 
....................  
.................... #include "generic_uart.c" 
.................... #include "generic_uart.h" 
.................... /*  
....................  * File:   generic_uart.h 
....................  * Author: artga 
....................  * 
....................  * Created on 12 de enero de 2022, 12:20 PM 
....................  */ 
....................  
.................... #ifndef GENERIC_UART_H 
.................... #define	GENERIC_UART_H 
....................  
.................... #define UART_INT_RDA     	11111 
.................... #define UART_INT_RDA2		22222 
.................... #define UART_INT_RDA3    	33333 
.................... #define UART_INT_RDA4    	44444 
.................... #define UART_INT_RDA5       55555   
....................  
.................... #define BUFFER_SIZE 255 
.................... #ifndef DEVICE_DEBUG 
.................... #define DEVICE_DEBUG FALSE 
.................... #endif 
....................  
.................... struct data_uart{ 
....................     char buffer[BUFFER_SIZE]; 
....................     BOOLEAN AVAILABLE; 
....................     long len; 
....................          
.................... }data; 
.................... /*Generic functions*/ 
.................... void device_init(void); 
.................... BOOLEAN device_reset(BOOLEAN pulse, long time_ms); 
.................... void data_send(char* buffer, long len); 
.................... BOOLEAN data_timeout(long millis); 
....................  
.................... #include "generic_uart.c" 
....................  
.................... #endif	/* GENERIC_UART_H */ 
....................  
....................  
....................  
.................... #if (DEVICE_SERIAL_SOURCE == UART_INT_RDA) 
.................... #use rs232(baud=DEVICE_SERIAL_BAUD,parity=N,UART1,bits=8,stream=UART_PORT,restart_wdt,errors) 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA2) 
.................... #use rs232(baud=DEVICE_SERIAL_BAUD,parity=N,UART2,bits=8,stream=UART_PORT,restart_wdt,errors) 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA3) 
.................... #use rs232(baud=DEVICE_SERIAL_BAUD,parity=N,UART3,bits=8,stream=UART_PORT,restart_wdt,errors) 
*
00412:  CLRWDT
00414:  MOVLB  E
00416:  BTFSC  x37.1
00418:  BRA    041E
0041A:  MOVLB  0
0041C:  BRA    0412
0041E:  MOVFF  EEE,28
00422:  MOVFF  EEA,01
00426:  BTFSS  28.1
00428:  BRA    042E
0042A:  BCF    xEE.4
0042C:  BSF    xEE.4
0042E:  MOVLB  0
00430:  GOTO   0438 (RETURN)
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA4) 
.................... #use rs232(baud=DEVICE_SERIAL_BAUD,parity=N,UART4,bits=8,stream=UART_PORT,restart_wdt,errors) 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA5) 
.................... #use rs232(baud=DEVICE_SERIAL_BAUD,parity=N,UART5,bits=8,stream=UART_PORT,restart_wdt,errors) 
.................... #endif 
....................  
....................  
.................... #if (DEVICE_SERIAL_SOURCE == UART_INT_RDA) 
.................... #int_rda 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA2) 
.................... #int_rda2 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA3) 
.................... #int_rda3 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA4) 
.................... #int_rda4 
.................... #elif (DEVICE_SERIAL_SOURCE == UART_INT_RDA5) 
.................... #int_rda5 
.................... #endif 
.................... void uart_serial_rcv(){ 
00434:  MOVLB  0
00436:  BRA    0412
00438:  MOVFF  01,1E0
....................     static int16 replyidx = 0; 
....................     char c = fgetc(UART_PORT); 
....................     if (replyidx < BUFFER_SIZE) { 
0043C:  MOVLB  1
0043E:  MOVF   x75,F
00440:  BNZ   0466
00442:  MOVF   x74,W
00444:  SUBLW  FE
00446:  BNC   0466
....................         data.buffer[replyidx++] = c; 
00448:  MOVFF  175,03
0044C:  MOVF   x74,W
0044E:  INCF   x74,F
00450:  BTFSC  FD8.2
00452:  INCF   x75,F
00454:  MOVWF  xE1
00456:  MOVLW  72
00458:  ADDWF  xE1,W
0045A:  MOVWF  FE9
0045C:  MOVLW  00
0045E:  ADDWFC 03,W
00460:  MOVWF  FEA
00462:  MOVFF  1E0,FEF
....................  
....................     } 
....................  
....................      
....................     if(c == '\n' || replyidx >=10){ 
00466:  MOVF   xE0,W
00468:  SUBLW  0A
0046A:  BZ    0476
0046C:  MOVF   x75,F
0046E:  BNZ   0476
00470:  MOVF   x74,W
00472:  SUBLW  09
00474:  BC    0492
....................         data.buffer[replyidx] = 0; 
00476:  MOVLW  72
00478:  ADDWF  x74,W
0047A:  MOVWF  FE9
0047C:  MOVLW  00
0047E:  ADDWFC x75,W
00480:  MOVWF  FEA
00482:  CLRF   FEF
....................         data.len = replyidx; 
00484:  MOVFF  175,173
00488:  MOVFF  174,172
....................         data.AVAILABLE = TRUE; 
0048C:  BSF    x71.0
....................         replyidx = 0; 
0048E:  CLRF   x75
00490:  CLRF   x74
....................     } 
00492:  MOVLB  E
00494:  BCF    x37.1
00496:  MOVLB  0
00498:  GOTO   0082
.................... } 
.................... /*void uart_serial_rcv(){ 
....................     int16 timeout = 500; 
....................     int16 replyidx = 0; 
....................     int16 timeoutBack = timeout; 
....................     while(timeout--){ 
....................         if(replyidx >= BUFFER_SIZE){ 
....................             break; 
....................         } 
....................         if(kbhit(UART_PORT)){ 
....................             timeout = timeoutBack; 
....................             char c = fgetc(UART_PORT);             
....................             data.buffer[replyidx] = c; 
....................             replyidx++; 
....................         } 
....................         if(timeout == 0){ 
....................             break; 
....................         } 
....................     } 
....................     data.buffer[replyidx] = 0; //null term 
....................     data.AVAILABLE = TRUE; 
....................     data.len = replyidx; 
.................... }*/ 
....................  
.................... void clean_buffer(void){ 
....................     memset(data.buffer,0,sizeof(data.buffer)); 
*
00540:  CLRF   FEA
00542:  MOVLW  72
00544:  MOVWF  FE9
00546:  CLRF   00
00548:  CLRF   02
0054A:  SETF   01
0054C:  BRA    0524
0054E:  GOTO   055E (RETURN)
.................... } 
....................  
.................... void device_init(void){ 
....................      
....................     data.AVAILABLE = FALSE; 
00552:  MOVLB  1
00554:  BCF    x71.0
....................     data.len = 0; 
00556:  CLRF   x73
00558:  CLRF   x72
....................     clean_buffer(); 
0055A:  MOVLB  0
0055C:  BRA    0540
.................... #if (DEVICE_SERIAL_SOURCE==UART_INT_RDA) 
....................     clear_interrupt(INT_RDA); 
....................     enable_interrupts(INT_RDA); 
.................... #elif (DEVICE_SERIAL_SOURCE==UART_INT_RDA2) 
....................     clear_interrupt(INT_RDA2); 
....................     enable_interrupts(INT_RDA2); 
.................... #elif (DEVICE_SERIAL_SOURCE==UART_INT_RDA3) 
....................     clear_interrupt(INT_RDA3); 
0055E:  MOVLB  E
00560:  MOVF   xEA,W
....................     enable_interrupts(INT_RDA3); 
00562:  BSF    x2D.1
.................... #elif (DEVICE_SERIAL_SOURCE==UART_INT_RDA4) 
00564:  MOVLB  0
00566:  GOTO   18AC (RETURN)
....................     clear_interrupt(INT_RDA4); 
....................     enable_interrupts(INT_RDA4); 
.................... #elif (DEVICE_SERIAL_SOURCE==UART_INT_RDA5) 
....................    clear_interrupt(INT_RDA5); 
....................    enable_interrupts(INT_RDA5); 
.................... #endif 
.................... } 
.................... BOOLEAN device_reset(BOOLEAN pulse, long time_ms){ 
....................     if (pulse) { 
....................         output_high(DEVICE_RST_PIN); 
....................         delay_ms(time_ms); 
....................         output_low(DEVICE_RST_PIN); 
....................         while(input(DEVICE_RST_PIN)){ 
....................             DEBUG_MSG("1 En RST \r\n"); 
....................         } 
....................  
....................     }else{ 
....................         output_low(DEVICE_RST_PIN); 
....................         delay_ms(time_ms); 
....................         output_high(DEVICE_RST_PIN); 
....................         while(!input(DEVICE_RST_PIN)){ 
....................             DEBUG_MSG("0 En RST\r\n"); 
....................         } 
....................          
....................     } 
....................     return true; 
....................      
....................  
.................... } 
....................  
.................... void data_send(char* buffer, long len){ 
....................     long i; 
....................     for (i = 0; i < len; i++) { 
....................         fputc(buffer[i],UART_PORT); 
....................     } 
.................... #if (DEVICE_DEBUG == TRUE) 
....................     DEBUG_MSG("[DEBUG]Data sent: ["); 
....................     for (i = 0; i < len; i++) { 
....................         DEBUG_DATA("%X:",buffer[i]); 
....................     } 
....................     DEBUG_MSG("]\n"); 
.................... #endif 
....................      
....................  
.................... } 
....................  
.................... BOOLEAN data_timeout(long millis){ 
....................     int16 timeout_ms = 0; 
....................     while (!data.AVAILABLE && millis > timeout_ms) { 
....................         timeout_ms++; 
....................         delay_ms(1); 
....................     } 
....................      
....................  
....................     if (data.AVAILABLE) { 
.................... #if (DEVICE_DEBUG == TRUE)  
....................         DEBUG_MSG("[DEVICE] Data available\r\n"); 
.................... #endif 
....................         return FALSE; 
....................     } 
....................     else if(timeout_ms >= millis){ 
.................... #if (DEVICE_DEBUG == TRUE)  
....................         DEBUG_MSG("[DEVICE] Timeout Serial\r\n"); 
.................... #endif 
....................         return TRUE; 
....................     } 
....................  
.................... } 
....................  
....................  
.................... #endif	/* GENERIC_UART_H */ 
....................  
....................  
....................  
.................... #define MODBUS_ADDRESS 0x01 
.................... #define DELAY_LED   1000 
....................  
....................  
....................  
.................... // Buffer para recibir la trama (ajustado al tamao tpico) 
.................... //char trama[16]; 
.................... //int trama_index = 0; 
....................  
.................... int8 coils = 0b00000101; 
.................... int8 inputs = 0b00001001; 
.................... //int16 hold_regs[] = {0x8800,0x7700,0x6600,0x5500,0x4400,0x3300,0x2200,0x1100}; 
.................... //int16 input_regs[] = {0x1100,0x2200,0x3300,0x4400,0x5500,0x6600,0x7700,0x8800}; 
.................... int16 event_count = 0; 
.................... int16 input_registers[10]; 
.................... int16 holding_registers[10]; 
.................... // Variables extradas 
.................... long long peso_int32 = 0; 
.................... long peso_hi, peso_lo; 
.................... float peso = 0.0; 
.................... char unidad[3] = {0}; // 2 letras + terminador 
.................... char estado = 0; 
....................  
.................... // Funcin para procesar la trama completa 
....................  
.................... void procesar_trama() { 
....................     char peso_str[8]; // Para "+0123.4" 
....................     //Para indicador ricelake 120 
....................     if (data.buffer[0] == 0x02) { // Verifica que inicie con STX 
*
00D4E:  MOVF   x72,W
00D50:  SUBLW  02
00D52:  BNZ   0DA4
....................         // Copiar peso 
....................         strncpy(peso_str, &data.buffer[1], 7); 
00D54:  MOVLW  01
00D56:  MOVLB  1
00D58:  MOVWF  xBE
00D5A:  MOVLW  B5
00D5C:  MOVWF  xBD
00D5E:  CLRF   xC0
00D60:  MOVLW  73
00D62:  MOVWF  xBF
00D64:  CLRF   xC2
00D66:  MOVLW  07
00D68:  MOVWF  xC1
00D6A:  MOVLB  0
00D6C:  CALL   056A
....................         peso_str[7] = '\0'; // Fin de cadena 
00D70:  MOVLB  1
00D72:  CLRF   xBC
....................  
....................         // Copiar unidad 
....................         unidad[0] = data.buffer[8]; 
00D74:  MOVFF  7A,1B0
....................         unidad[1] = data.buffer[9]; 
00D78:  MOVFF  7B,1B1
....................         unidad[2] = '\0'; 
00D7C:  CLRF   xB2
....................  
....................         // Copiar estado 
....................         estado = data.buffer[10]; 
00D7E:  MOVFF  7C,1B3
....................  
....................         // Convertir peso 
....................         peso = atof(peso_str); 
00D82:  MOVLW  01
00D84:  MOVWF  xBE
00D86:  MOVLW  B5
00D88:  MOVWF  xBD
00D8A:  CLRF   xC0
00D8C:  CLRF   xBF
00D8E:  MOVLB  0
00D90:  RCALL  0AFC
00D92:  MOVFF  03,1AF
00D96:  MOVFF  02,1AE
00D9A:  MOVFF  01,1AD
00D9E:  MOVFF  00,1AC
....................  
....................  
....................         // Ahora tienes el peso como float, unidad y estado 
....................         //fprintf(DEBUG,"Peso: %.2f %s\n", peso, unidad); 
....................         //fprintf(DEBUG,"Estado: %c\n", estado); 
....................     }//Para indicador YP200 
00DA2:  BRA    0DEA
....................     else if (data.buffer[0] == 0x3D) { 
00DA4:  MOVF   x72,W
00DA6:  SUBLW  3D
00DA8:  BNZ   0DEA
....................         strncpy(peso_str, data.buffer + 1, 7); 
00DAA:  MOVLW  01
00DAC:  MOVLB  1
00DAE:  MOVWF  xBE
00DB0:  MOVLW  B5
00DB2:  MOVWF  xBD
00DB4:  CLRF   xC0
00DB6:  MOVLW  73
00DB8:  MOVWF  xBF
00DBA:  CLRF   xC2
00DBC:  MOVLW  07
00DBE:  MOVWF  xC1
00DC0:  MOVLB  0
00DC2:  CALL   056A
....................         peso_str[7] = '\0'; 
00DC6:  MOVLB  1
00DC8:  CLRF   xBC
....................         peso = atof(peso_str); 
00DCA:  MOVLW  01
00DCC:  MOVWF  xBE
00DCE:  MOVLW  B5
00DD0:  MOVWF  xBD
00DD2:  CLRF   xC0
00DD4:  CLRF   xBF
00DD6:  MOVLB  0
00DD8:  RCALL  0AFC
00DDA:  MOVFF  03,1AF
00DDE:  MOVFF  02,1AE
00DE2:  MOVFF  01,1AD
00DE6:  MOVFF  00,1AC
....................         //fprintf(DEBUG, "Peso: %.2f \n",peso); 
....................     } else { 
....................         //DEBUG_MSG("WRONG PROTOCOL"); 
....................     } 
....................     output_toggle(LED2); 
00DEA:  BCF    F86.1
00DEC:  BTG    F7E.1
00DEE:  GOTO   18BE (RETURN)
.................... } 
....................  
....................  
....................  
....................  
....................  
....................  
....................  
....................  
.................... //int16 value = 0; 
....................  
.................... int8 swap_bits(int8 c) { 
....................     return ((c & 1) ? 128 : 0) | ((c & 2) ? 64 : 0) | ((c & 4) ? 32 : 0) | ((c & 8) ? 16 : 0) | ((c & 16) ? 8 : 0) 
....................             | ((c & 32) ? 4 : 0) | ((c & 64) ? 2 : 0) | ((c & 128) ? 1 : 0); 
*
011D4:  MOVLB  1
011D6:  BTFSS  xBA.0
011D8:  BRA    11DE
011DA:  MOVLW  80
011DC:  BRA    11E0
011DE:  MOVLW  00
011E0:  MOVWF  xBB
011E2:  BTFSS  xBA.1
011E4:  BRA    11EA
011E6:  MOVLW  40
011E8:  BRA    11EC
011EA:  MOVLW  00
011EC:  IORWF  xBB,F
011EE:  BTFSS  xBA.2
011F0:  BRA    11F6
011F2:  MOVLW  20
011F4:  BRA    11F8
011F6:  MOVLW  00
011F8:  IORWF  xBB,F
011FA:  BTFSS  xBA.3
011FC:  BRA    1202
011FE:  MOVLW  10
01200:  BRA    1204
01202:  MOVLW  00
01204:  IORWF  xBB,F
01206:  BTFSS  xBA.4
01208:  BRA    120E
0120A:  MOVLW  08
0120C:  BRA    1210
0120E:  MOVLW  00
01210:  IORWF  xBB,F
01212:  BTFSS  xBA.5
01214:  BRA    121A
01216:  MOVLW  04
01218:  BRA    121C
0121A:  MOVLW  00
0121C:  IORWF  xBB,F
0121E:  BTFSS  xBA.6
01220:  BRA    1226
01222:  MOVLW  02
01224:  BRA    1228
01226:  MOVLW  00
01228:  IORWF  xBB,F
0122A:  BTFSS  xBA.7
0122C:  BRA    1232
0122E:  MOVLW  01
01230:  BRA    1234
01232:  MOVLW  00
01234:  IORWF  xBB,W
01236:  MOVWF  01
01238:  MOVLB  0
0123A:  GOTO   158C (RETURN)
.................... } 
....................  
.................... void procesar_modbus(void) { 
....................     //check address against our address, 0 is broadcast 
....................     if ((modbus_rx.address == MODBUS_ADDRESS) || modbus_rx.address == 0) { 
*
012B6:  DECFSZ 2A,W
012B8:  BRA    12BC
012BA:  BRA    12C2
012BC:  MOVF   2A,F
012BE:  BTFSS  FD8.2
012C0:  BRA    1710
....................         //output_high(LED1); 
....................         //delay_ms(10); 
....................         output_toggle(LED1); 
012C2:  BCF    F86.0
012C4:  BTG    F7E.0
....................         switch (modbus_rx.func) { 
012C6:  MOVF   2C,W
012C8:  XORLW  01
012CA:  BZ    12F6
012CC:  XORLW  03
012CE:  BZ    12F8
012D0:  XORLW  01
012D2:  BTFSC  FD8.2
012D4:  BRA    13B4
012D6:  XORLW  07
012D8:  BTFSC  FD8.2
012DA:  BRA    13B4
012DC:  XORLW  01
012DE:  BTFSC  FD8.2
012E0:  BRA    144C
012E2:  XORLW  03
012E4:  BTFSC  FD8.2
012E6:  BRA    14F4
012E8:  XORLW  09
012EA:  BTFSC  FD8.2
012EC:  BRA    155A
012EE:  XORLW  1F
012F0:  BTFSC  FD8.2
012F2:  BRA    1630
012F4:  BRA    16FE
....................             case FUNC_READ_COILS: //read coils 
....................                 //DEBUG_MSG("[DEBUG] FUNC_READ_COILS \r\n"); 
....................                 break; 
012F6:  BRA    1710
....................             case FUNC_READ_DISCRETE_INPUT: //read inputs 
....................                 //DEBUG_MSG("[DEBUG] FUNC_READ_DISCRETE_INPUT \r\n"); 
....................                 if (modbus_rx.data[0] || modbus_rx.data[2] || 
....................                         modbus_rx.data[1] >= 8 || modbus_rx.data[3] + modbus_rx.data[1] > 8) 
012F8:  MOVF   2E,F
012FA:  BNZ   130E
012FC:  MOVF   30,F
012FE:  BNZ   130E
01300:  MOVF   2F,W
01302:  SUBLW  07
01304:  BNC   130E
01306:  MOVF   2F,W
01308:  ADDWF  31,W
0130A:  SUBLW  08
0130C:  BC    1324
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
0130E:  MOVLW  01
01310:  MOVLB  1
01312:  MOVWF  xBA
01314:  CLRF   xBC
01316:  MOVFF  2C,1BB
0131A:  MOVLW  02
0131C:  MOVWF  xBD
0131E:  MOVLB  0
01320:  RCALL  0FB8
01322:  BRA    13B2
....................                 else { 
....................                     int8 data; 
....................  
....................                     if (modbus_rx.func == FUNC_READ_COILS) 
01324:  DECFSZ 2C,W
01326:  BRA    1346
....................                         data = coils >> (modbus_rx.data[1]); //move to the starting coil 
01328:  MOVFF  178,1B5
0132C:  MOVF   2F,W
0132E:  MOVWF  01
01330:  BZ    1344
01332:  BCF    FD8.0
01334:  MOVLB  1
01336:  RRCF   xB5,F
01338:  DECFSZ 01,F
0133A:  BRA    133E
0133C:  BRA    1342
0133E:  MOVLB  0
01340:  BRA    1332
01342:  MOVLB  0
01344:  BRA    1362
....................                     else 
....................                         data = inputs >> (modbus_rx.data[1]); //move to the starting input 
01346:  MOVFF  179,1B5
0134A:  MOVF   2F,W
0134C:  MOVWF  01
0134E:  BZ    1362
01350:  BCF    FD8.0
01352:  MOVLB  1
01354:  RRCF   xB5,F
01356:  DECFSZ 01,F
01358:  BRA    135C
0135A:  BRA    1360
0135C:  MOVLB  0
0135E:  BRA    1350
01360:  MOVLB  0
....................  
....................                     data = data & (0xFF >> (8 - modbus_rx.data[3])); //0 out values after quantity 
01362:  MOVLW  08
01364:  BSF    FD8.0
01366:  SUBFWB 31,W
01368:  MOVWF  01
0136A:  SETF   00
0136C:  MOVF   01,F
0136E:  BZ    1378
01370:  BCF    FD8.0
01372:  RRCF   00,F
01374:  DECFSZ 01,F
01376:  BRA    1370
01378:  MOVF   00,W
0137A:  MOVLB  1
0137C:  ANDWF  xB5,F
....................  
....................                     if (modbus_rx.func == FUNC_READ_COILS) 
0137E:  DECFSZ 2C,W
01380:  BRA    1398
....................                         modbus_read_coils_rsp(MODBUS_ADDRESS, 0x01, &data); 
01382:  MOVLW  01
01384:  MOVWF  xBA
01386:  MOVWF  xBB
01388:  MOVWF  xBD
0138A:  MOVLW  B5
0138C:  MOVWF  xBC
0138E:  MOVLB  0
01390:  BRA    0FD8
01392:  MOVLB  0
01394:  BRA    13A8
01396:  MOVLB  1
....................                     else 
....................                         modbus_read_discrete_input_rsp(MODBUS_ADDRESS, 0x01, &data); 
01398:  MOVLW  01
0139A:  MOVWF  xBA
0139C:  MOVWF  xBB
0139E:  MOVWF  xBD
013A0:  MOVLW  B5
013A2:  MOVWF  xBC
013A4:  MOVLB  0
013A6:  BRA    101E
....................  
....................                     event_count++; 
013A8:  MOVLB  1
013AA:  INCF   x7A,F
013AC:  BTFSC  FD8.2
013AE:  INCF   x7B,F
013B0:  MOVLB  0
....................                 } 
....................                 break; 
013B2:  BRA    1710
....................             case FUNC_READ_HOLDING_REGISTERS: 
....................             case FUNC_READ_INPUT_REGISTERS: 
....................  
....................                 if (modbus_rx.data[0] || modbus_rx.data[2] || 
....................                         modbus_rx.data[1] >= 8 || modbus_rx.data[3] + modbus_rx.data[1] > 8) { 
013B4:  MOVF   2E,F
013B6:  BNZ   13CA
013B8:  MOVF   30,F
013BA:  BNZ   13CA
013BC:  MOVF   2F,W
013BE:  SUBLW  07
013C0:  BNC   13CA
013C2:  MOVF   2F,W
013C4:  ADDWF  31,W
013C6:  SUBLW  08
013C8:  BC    13E0
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
013CA:  MOVLW  01
013CC:  MOVLB  1
013CE:  MOVWF  xBA
013D0:  CLRF   xBC
013D2:  MOVFF  2C,1BB
013D6:  MOVLW  02
013D8:  MOVWF  xBD
013DA:  MOVLB  0
013DC:  RCALL  0FB8
....................                 } else { 
013DE:  BRA    144A
....................                     if (modbus_rx.func == FUNC_READ_HOLDING_REGISTERS) { 
013E0:  MOVF   2C,W
013E2:  SUBLW  03
013E4:  BNZ   1414
....................                         // DEBUG_MSG("[DEBUG] FUNC_READ_HOLDING_REGISTERS \r\n"); 
....................                         modbus_read_holding_registers_rsp(MODBUS_ADDRESS, (modbus_rx.data[3]*2), holding_registers + modbus_rx.data[1]); 
013E6:  BCF    FD8.0
013E8:  RLCF   31,W
013EA:  MOVLB  1
013EC:  MOVWF  xBA
013EE:  BCF    FD8.0
013F0:  RLCF   2F,W
013F2:  ADDLW  90
013F4:  MOVWF  xBB
013F6:  MOVLW  01
013F8:  MOVWF  xBC
013FA:  BTFSC  FD8.0
013FC:  INCF   xBC,F
013FE:  MOVLW  01
01400:  MOVWF  xBD
01402:  MOVFF  1BA,1BE
01406:  MOVFF  1BC,1C0
0140A:  MOVFF  1BB,1BF
0140E:  MOVLB  0
01410:  BRA    1064
....................                     } else { 
01412:  BRA    1440
....................                         // DEBUG_MSG("[DEBUG] FUNC_READ_INPUT_REGISTERS \r\n"); 
....................                         modbus_read_input_registers_rsp(MODBUS_ADDRESS, (modbus_rx.data[3]*2), input_registers + modbus_rx.data[1]); 
01414:  BCF    FD8.0
01416:  RLCF   31,W
01418:  MOVLB  1
0141A:  MOVWF  xBA
0141C:  BCF    FD8.0
0141E:  RLCF   2F,W
01420:  ADDLW  7C
01422:  MOVWF  xBB
01424:  MOVLW  01
01426:  MOVWF  xBC
01428:  BTFSC  FD8.0
0142A:  INCF   xBC,F
0142C:  MOVLW  01
0142E:  MOVWF  xBD
01430:  MOVFF  1BA,1BE
01434:  MOVFF  1BC,1C0
01438:  MOVFF  1BB,1BF
0143C:  MOVLB  0
0143E:  BRA    10E0
....................                     } 
....................  
....................                     event_count++; 
01440:  MOVLB  1
01442:  INCF   x7A,F
01444:  BTFSC  FD8.2
01446:  INCF   x7B,F
01448:  MOVLB  0
....................                     //output_low(LED1); 
....................                 } 
....................                 break; 
0144A:  BRA    1710
....................             case FUNC_WRITE_SINGLE_COIL: //write coil 
....................                 //DEBUG_MSG("[DEBUG] FUNC_WRITE_SINGLE_COIL \r\n"); 
....................                 if (modbus_rx.data[0] || modbus_rx.data[3] || modbus_rx.data[1] > 8) 
0144C:  MOVF   2E,F
0144E:  BNZ   145A
01450:  MOVF   31,F
01452:  BNZ   145A
01454:  MOVF   2F,W
01456:  SUBLW  08
01458:  BC    1470
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
0145A:  MOVLW  01
0145C:  MOVLB  1
0145E:  MOVWF  xBA
01460:  CLRF   xBC
01462:  MOVFF  2C,1BB
01466:  MOVLW  02
01468:  MOVWF  xBD
0146A:  MOVLB  0
0146C:  RCALL  0FB8
0146E:  BRA    14F2
....................                 else if (modbus_rx.data[2] != 0xFF && modbus_rx.data[2] != 0x00) 
01470:  INCFSZ 30,W
01472:  BRA    1476
01474:  BRA    1490
01476:  MOVF   30,F
01478:  BZ    1490
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_VALUE); 
0147A:  MOVLW  01
0147C:  MOVLB  1
0147E:  MOVWF  xBA
01480:  CLRF   xBC
01482:  MOVFF  2C,1BB
01486:  MOVLW  03
01488:  MOVWF  xBD
0148A:  MOVLB  0
0148C:  RCALL  0FB8
0148E:  BRA    14F2
....................                 else { 
....................                     if (modbus_rx.data[2] == 0xFF) 
01490:  INCFSZ 30,W
01492:  BRA    14B0
....................                         bit_set(coils, modbus_rx.data[1]); 
01494:  MOVLW  01
01496:  MOVWF  00
01498:  MOVF   2F,W
0149A:  MOVWF  01
0149C:  BZ    14A6
0149E:  BCF    FD8.0
014A0:  RLCF   00,F
014A2:  DECFSZ 01,F
014A4:  BRA    149E
014A6:  MOVF   00,W
014A8:  MOVLB  1
014AA:  IORWF  x78,F
014AC:  BRA    14CA
014AE:  MOVLB  0
....................                     else 
....................                         bit_clear(coils, modbus_rx.data[1]); 
014B0:  MOVLW  01
014B2:  MOVWF  00
014B4:  MOVF   2F,W
014B6:  MOVWF  01
014B8:  BZ    14C2
014BA:  BCF    FD8.0
014BC:  RLCF   00,F
014BE:  DECFSZ 01,F
014C0:  BRA    14BA
014C2:  MOVF   00,W
014C4:  XORLW  FF
014C6:  MOVLB  1
014C8:  ANDWF  x78,F
....................  
....................                     modbus_write_single_coil_rsp(MODBUS_ADDRESS, modbus_rx.data[1], ((int16) (modbus_rx.data[2])) << 8); 
014CA:  CLRF   xBB
014CC:  MOVFF  30,1BB
014D0:  CLRF   xBA
014D2:  MOVLW  01
014D4:  MOVWF  xBC
014D6:  CLRF   xBE
014D8:  MOVFF  2F,1BD
014DC:  MOVFF  30,1C0
014E0:  MOVFF  1BA,1BF
014E4:  MOVLB  0
014E6:  BRA    115C
....................  
....................                     event_count++; 
014E8:  MOVLB  1
014EA:  INCF   x7A,F
014EC:  BTFSC  FD8.2
014EE:  INCF   x7B,F
014F0:  MOVLB  0
....................                 } 
....................                 break; 
014F2:  BRA    1710
....................             case FUNC_WRITE_SINGLE_REGISTER: 
....................                 //DEBUG_MSG("[DEBUG] FUNC_WRITE_SINGLE_REGISTER \r\n"); 
....................                 if (modbus_rx.data[0] || modbus_rx.data[1] >= 8) 
014F4:  MOVF   2E,F
014F6:  BNZ   14FE
014F8:  MOVF   2F,W
014FA:  SUBLW  07
014FC:  BC    1514
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
014FE:  MOVLW  01
01500:  MOVLB  1
01502:  MOVWF  xBA
01504:  CLRF   xBC
01506:  MOVFF  2C,1BB
0150A:  MOVLW  02
0150C:  MOVWF  xBD
0150E:  MOVLB  0
01510:  RCALL  0FB8
01512:  BRA    1558
....................                 else { 
....................                     holding_registers[modbus_rx.data[1]] = make16(modbus_rx.data[2], modbus_rx.data[3]); 
01514:  BCF    FD8.0
01516:  RLCF   2F,W
01518:  CLRF   03
0151A:  ADDLW  90
0151C:  MOVWF  FE9
0151E:  MOVLW  01
01520:  ADDWFC 03,W
01522:  MOVWF  FEA
01524:  MOVFF  30,FEC
01528:  MOVF   FED,F
0152A:  MOVFF  31,FEF
....................  
....................                     modbus_write_single_register_rsp(MODBUS_ADDRESS, 
....................                             make16(modbus_rx.data[0], modbus_rx.data[1]), 
....................                             make16(modbus_rx.data[2], modbus_rx.data[3])); 
0152E:  MOVFF  2E,1BB
01532:  MOVFF  2F,1BA
01536:  MOVFF  30,1BD
0153A:  MOVFF  31,1BC
0153E:  MOVLW  01
01540:  MOVLB  1
01542:  MOVWF  xBE
01544:  MOVFF  2E,1C0
01548:  MOVFF  2F,1BF
0154C:  MOVFF  30,1C2
01550:  MOVFF  31,1C1
01554:  MOVLB  0
01556:  BRA    1198
....................                 } 
....................                 break; 
01558:  BRA    1710
....................             case FUNC_WRITE_MULTIPLE_COILS: 
....................                 //DEBUG_MSG("[DEBUG] FUNC_WRITE_MULTIPLE_COILS \r\n"); 
....................                 if (modbus_rx.data[0] || modbus_rx.data[2] || 
....................                         modbus_rx.data[1] >= 8 || modbus_rx.data[3] + modbus_rx.data[1] > 8) 
0155A:  MOVF   2E,F
0155C:  BNZ   1570
0155E:  MOVF   30,F
01560:  BNZ   1570
01562:  MOVF   2F,W
01564:  SUBLW  07
01566:  BNC   1570
01568:  MOVF   2F,W
0156A:  ADDWF  31,W
0156C:  SUBLW  08
0156E:  BC    1586
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
01570:  MOVLW  01
01572:  MOVLB  1
01574:  MOVWF  xBA
01576:  CLRF   xBC
01578:  MOVFF  2C,1BB
0157C:  MOVLW  02
0157E:  MOVWF  xBD
01580:  MOVLB  0
01582:  RCALL  0FB8
01584:  BRA    162E
....................                 else { 
....................                     int i, j; 
....................  
....................                     modbus_rx.data[5] = swap_bits(modbus_rx.data[5]); 
01586:  MOVFF  33,1BA
0158A:  BRA    11D4
0158C:  MOVFF  01,33
....................  
....................                     for (i = modbus_rx.data[1], j = 0; i < modbus_rx.data[1] + modbus_rx.data[3]; ++i, ++j) { 
01590:  MOVFF  2F,1B6
01594:  MOVLB  1
01596:  CLRF   xB7
01598:  MOVF   31,W
0159A:  ADDWF  2F,W
0159C:  SUBWF  xB6,W
0159E:  BC    15FC
....................                         if (bit_test(modbus_rx.data[5], j)) 
015A0:  MOVFF  33,00
015A4:  MOVF   xB7,W
015A6:  MOVWF  01
015A8:  BZ    15B2
015AA:  BCF    FD8.0
015AC:  RRCF   00,F
015AE:  DECFSZ 01,F
015B0:  BRA    15AA
015B2:  BTFSS  00.0
015B4:  BRA    15D6
....................                             bit_set(coils, 7 - i); 
015B6:  MOVLW  07
015B8:  BSF    FD8.0
015BA:  SUBFWB xB6,W
015BC:  MOVWF  xBA
015BE:  MOVLW  01
015C0:  MOVWF  00
015C2:  MOVF   xBA,W
015C4:  MOVWF  01
015C6:  BZ    15D0
015C8:  BCF    FD8.0
015CA:  RLCF   00,F
015CC:  DECFSZ 01,F
015CE:  BRA    15C8
015D0:  MOVF   00,W
015D2:  IORWF  x78,F
015D4:  BRA    15F6
....................                         else 
....................                             bit_clear(coils, 7 - i); 
015D6:  MOVLW  07
015D8:  BSF    FD8.0
015DA:  SUBFWB xB6,W
015DC:  MOVWF  xBA
015DE:  MOVLW  01
015E0:  MOVWF  00
015E2:  MOVF   xBA,W
015E4:  MOVWF  01
015E6:  BZ    15F0
015E8:  BCF    FD8.0
015EA:  RLCF   00,F
015EC:  DECFSZ 01,F
015EE:  BRA    15E8
015F0:  MOVF   00,W
015F2:  XORLW  FF
015F4:  ANDWF  x78,F
015F6:  INCF   xB6,F
015F8:  INCF   xB7,F
015FA:  BRA    1598
....................                     } 
....................  
....................                     modbus_write_multiple_coils_rsp(MODBUS_ADDRESS, 
....................                             make16(modbus_rx.data[0], modbus_rx.data[1]), 
....................                             make16(modbus_rx.data[2], modbus_rx.data[3])); 
015FC:  MOVFF  2E,1BB
01600:  MOVFF  2F,1BA
01604:  MOVFF  30,1BD
01608:  MOVFF  31,1BC
0160C:  MOVLW  01
0160E:  MOVWF  xBE
01610:  MOVFF  2E,1C0
01614:  MOVFF  2F,1BF
01618:  MOVFF  30,1C2
0161C:  MOVFF  31,1C1
01620:  MOVLB  0
01622:  BRA    123E
....................  
....................                     event_count++; 
01624:  MOVLB  1
01626:  INCF   x7A,F
01628:  BTFSC  FD8.2
0162A:  INCF   x7B,F
0162C:  MOVLB  0
....................                 } 
....................                 break; 
0162E:  BRA    1710
....................             case FUNC_WRITE_MULTIPLE_REGISTERS: 
....................                 // DEBUG_MSG("[DEBUG] FUNC_WRITE_MULTIPLE_REGISTERS \r\n"); 
....................                 if (modbus_rx.data[0] || modbus_rx.data[2] || 
....................                         modbus_rx.data[1] >= 8 || modbus_rx.data[3] + modbus_rx.data[1] > 8) 
01630:  MOVF   2E,F
01632:  BNZ   1646
01634:  MOVF   30,F
01636:  BNZ   1646
01638:  MOVF   2F,W
0163A:  SUBLW  07
0163C:  BNC   1646
0163E:  MOVF   2F,W
01640:  ADDWF  31,W
01642:  SUBLW  08
01644:  BC    165C
....................                     modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_DATA_ADDRESS); 
01646:  MOVLW  01
01648:  MOVLB  1
0164A:  MOVWF  xBA
0164C:  CLRF   xBC
0164E:  MOVFF  2C,1BB
01652:  MOVLW  02
01654:  MOVWF  xBD
01656:  MOVLB  0
01658:  RCALL  0FB8
0165A:  BRA    16FC
....................                 else { 
....................                     int i, j; 
....................  
....................                     for (i = 0, j = 5; i < modbus_rx.data[4] / 2; ++i, j += 2) 
0165C:  MOVLB  1
0165E:  CLRF   xB8
01660:  MOVLW  05
01662:  MOVWF  xB9
01664:  BCF    FD8.0
01666:  RRCF   32,W
01668:  SUBWF  xB8,W
0166A:  BC    16CA
....................                         holding_registers[i] = make16(modbus_rx.data[j], modbus_rx.data[j + 1]); 
0166C:  BCF    FD8.0
0166E:  RLCF   xB8,W
01670:  CLRF   03
01672:  ADDLW  90
01674:  MOVWF  01
01676:  MOVLW  01
01678:  ADDWFC 03,F
0167A:  MOVFF  01,1BA
0167E:  MOVFF  03,1BB
01682:  CLRF   03
01684:  MOVF   xB9,W
01686:  ADDLW  2E
01688:  MOVWF  FE9
0168A:  MOVLW  00
0168C:  ADDWFC 03,W
0168E:  MOVWF  FEA
01690:  MOVFF  FEF,1BC
01694:  MOVLW  01
01696:  ADDWF  xB9,W
01698:  CLRF   03
0169A:  ADDLW  2E
0169C:  MOVWF  FE9
0169E:  MOVLW  00
016A0:  ADDWFC 03,W
016A2:  MOVWF  FEA
016A4:  MOVFF  FEF,1BD
016A8:  MOVFF  1BC,1BF
016AC:  MOVFF  1BD,1BE
016B0:  MOVFF  1BB,FEA
016B4:  MOVFF  01,FE9
016B8:  MOVFF  1BC,FEC
016BC:  MOVF   FED,F
016BE:  MOVFF  1BD,FEF
016C2:  INCF   xB8,F
016C4:  MOVLW  02
016C6:  ADDWF  xB9,F
016C8:  BRA    1664
....................  
....................                     modbus_write_multiple_registers_rsp(MODBUS_ADDRESS, 
....................                             make16(modbus_rx.data[0], modbus_rx.data[1]), 
....................                             make16(modbus_rx.data[2], modbus_rx.data[3])); 
016CA:  MOVFF  2E,1BB
016CE:  MOVFF  2F,1BA
016D2:  MOVFF  30,1BD
016D6:  MOVFF  31,1BC
016DA:  MOVLW  01
016DC:  MOVWF  xBE
016DE:  MOVFF  2E,1C0
016E2:  MOVFF  2F,1BF
016E6:  MOVFF  30,1C2
016EA:  MOVFF  31,1C1
016EE:  MOVLB  0
016F0:  BRA    127A
....................  
....................                     event_count++; 
016F2:  MOVLB  1
016F4:  INCF   x7A,F
016F6:  BTFSC  FD8.2
016F8:  INCF   x7B,F
016FA:  MOVLB  0
....................                 } 
....................                 break; 
016FC:  BRA    1710
....................             default: //We don't support the function, so return exception 
....................                 //DEBUG_MSG("[DEBUG] We dont Support the function \r\n"); 
....................                 modbus_exception_rsp(MODBUS_ADDRESS, modbus_rx.func, ILLEGAL_FUNCTION); 
016FE:  MOVLW  01
01700:  MOVLB  1
01702:  MOVWF  xBA
01704:  CLRF   xBC
01706:  MOVFF  2C,1BB
0170A:  MOVWF  xBD
0170C:  MOVLB  0
0170E:  RCALL  0FB8
....................         } 
....................     } 
01710:  GOTO   1914 (RETURN)
....................  
.................... } 
....................  
.................... void main() { 
01714:  BSF    F77.7
01716:  BCF    F77.6
01718:  CLRF   FF8
0171A:  BCF    FF2.5
0171C:  BSF    07.7
0171E:  MOVLB  E
01720:  MOVLW  55
01722:  MOVLB  D
01724:  MOVWF  xEF
01726:  MOVLW  AA
01728:  MOVWF  xEF
0172A:  BCF    xEF.0
0172C:  MOVLW  17
0172E:  MOVLB  E
01730:  MOVWF  x0F
01732:  MOVLW  32
01734:  MOVWF  x11
01736:  MOVLW  21
01738:  MOVWF  x13
0173A:  MOVLW  11
0173C:  MOVWF  x15
0173E:  MOVLW  23
01740:  MOVWF  x17
01742:  MOVLW  13
01744:  MOVWF  x19
01746:  MOVLW  14
01748:  MOVWF  x1A
0174A:  MOVLW  12
0174C:  MOVWF  x62
0174E:  MOVLW  0C
01750:  MOVWF  x68
01752:  MOVLW  10
01754:  MOVWF  x72
01756:  MOVLW  14
01758:  MOVWF  x74
0175A:  MOVLW  0E
0175C:  MOVWF  x83
0175E:  MOVLW  55
01760:  MOVLB  D
01762:  MOVWF  xEF
01764:  MOVLW  AA
01766:  MOVWF  xEF
01768:  BSF    xEF.0
0176A:  MOVLB  E
0176C:  CLRF   x48
0176E:  CLRF   x45
01770:  CLRF   x47
01772:  CLRF   x49
01774:  MOVLW  70
01776:  MOVWF  x43
01778:  CLRF   28
0177A:  BSF    F9E.3
0177C:  MOVLW  2A
0177E:  MOVWF  F9A
01780:  MOVLW  00
01782:  MOVWF  F9B
01784:  MOVLW  A6
01786:  MOVWF  F9D
01788:  MOVLW  90
0178A:  MOVWF  F9C
0178C:  BCF    29.0
0178E:  MOVLB  0
01790:  CLRF   x6E
01792:  MOVLW  01
01794:  MOVWF  FD2
01796:  MOVLW  33
01798:  MOVWF  FCF
0179A:  CLRF   FD0
0179C:  CLRF   FD1
0179E:  CLRF   FCE
017A0:  CLRF   FCD
017A2:  MOVLB  E
017A4:  BCF    x38.0
017A6:  BSF    x2E.0
017A8:  BSF    xE2.3
017AA:  MOVLW  2A
017AC:  MOVWF  xDE
017AE:  MOVLW  00
017B0:  MOVWF  xDF
017B2:  MOVLW  A6
017B4:  MOVWF  xE1
017B6:  MOVLW  90
017B8:  MOVWF  xE0
017BA:  BCF    29.1
017BC:  MOVLB  0
017BE:  CLRF   x6F
017C0:  MOVLB  E
017C2:  BSF    xF0.3
017C4:  MOVLW  08
017C6:  MOVWF  xEC
017C8:  MOVLW  02
017CA:  MOVWF  xED
017CC:  MOVLW  A6
017CE:  MOVWF  xEF
017D0:  MOVLW  90
017D2:  MOVWF  xEE
017D4:  MOVLB  1
017D6:  CLRF   x75
017D8:  CLRF   x74
017DA:  CLRF   x77
017DC:  CLRF   x76
017DE:  MOVLW  05
017E0:  MOVWF  x78
017E2:  MOVLW  09
017E4:  MOVWF  x79
017E6:  CLRF   x7B
017E8:  CLRF   x7A
017EA:  CLRF   xA7
017EC:  CLRF   xA6
017EE:  CLRF   xA5
017F0:  CLRF   xA4
017F2:  CLRF   xAF
017F4:  CLRF   xAE
017F6:  CLRF   xAD
017F8:  CLRF   xAC
017FA:  CLRF   xB3
017FC:  MOVLB  E
017FE:  CLRF   x92
01800:  CLRF   x9A
01802:  CLRF   xA7
01804:  CLRF   xAF
01806:  CLRF   xB4
01808:  CLRF   xBC
0180A:  CLRF   xD2
0180C:  CLRF   xD3
0180E:  CLRF   xD1
01810:  CLRF   xD0
01812:  MOVLW  01
01814:  MOVWF  1F
01816:  MOVLW  E5
01818:  MOVWF  1E
0181A:  MOVLW  0C
0181C:  MOVLB  1
0181E:  MOVWF  xE6
01820:  MOVLW  01
01822:  MOVWF  xE5
01824:  CLRF   xE8
01826:  CLRF   xE7
01828:  MOVLB  0
0182A:  CLRF   1C
0182C:  CLRF   1D
0182E:  MOVLB  1
01830:  CLRF   xB0
01832:  CLRF   xB1
01834:  CLRF   xB2
....................     //setup_oscillator(OSC_HFINTRC_64MHZ);  
....................  
....................     set_tris_a(0b00000001); //Pongo el RA0 como entrada 
01836:  MOVLW  01
01838:  MOVWF  F81
....................     set_tris_g(0b00000100); 
0183A:  MOVLW  04
0183C:  MOVWF  F87
....................     setup_adc_ports(sAN0); //Pongo todo el puerto a analogo 
0183E:  MOVLW  00
01840:  MOVLB  F
01842:  MOVWF  x58
01844:  MOVLW  01
01846:  MOVLB  E
01848:  MOVWF  x92
0184A:  MOVLW  00
0184C:  MOVWF  x9A
0184E:  MOVWF  xA7
01850:  MOVWF  xAF
01852:  MOVWF  xB4
01854:  MOVWF  xBC
....................     setup_adc(ADC_CLOCK_INTERNAL); //Selecciono reloj interno para conversion 
01856:  MOVLW  08
01858:  MOVLB  F
0185A:  MOVWF  x5A
0185C:  CLRF   x5B
0185E:  CLRF   x57
01860:  SETF   x5C
01862:  CLRF   F66
01864:  MOVLW  94
01866:  MOVWF  F60
....................  
....................  
....................  
....................  
....................     int i; 
....................     for (i = 0; i < 10; i++) { 
01868:  MOVLB  1
0186A:  CLRF   xB4
0186C:  MOVF   xB4,W
0186E:  SUBLW  09
01870:  BNC   18A2
....................         input_registers[i] = 0x0000; 
01872:  BCF    FD8.0
01874:  RLCF   xB4,W
01876:  CLRF   03
01878:  ADDLW  7C
0187A:  MOVWF  FE9
0187C:  MOVLW  01
0187E:  ADDWFC 03,W
01880:  MOVWF  FEA
01882:  CLRF   FEC
01884:  MOVF   FED,F
01886:  CLRF   FEF
....................         holding_registers[i] = 0x0000; 
01888:  BCF    FD8.0
0188A:  RLCF   xB4,W
0188C:  CLRF   03
0188E:  ADDLW  90
01890:  MOVWF  FE9
01892:  MOVLW  01
01894:  ADDWFC 03,W
01896:  MOVWF  FEA
01898:  CLRF   FEC
0189A:  MOVF   FED,F
0189C:  CLRF   FEF
0189E:  INCF   xB4,F
018A0:  BRA    186C
....................  
....................     } 
....................  
....................  
....................  
....................     modbus_init(); 
018A2:  MOVLB  0
018A4:  GOTO   0516
....................     device_init(); 
018A8:  GOTO   0552
....................     enable_interrupts(GLOBAL); 
018AC:  MOVLW  C0
018AE:  IORWF  FF2,F
....................     // si funciona  
....................     //peso = 999999.0; 
....................     //peso_int32 = peso;  
....................     // peso_hi = (int16)(peso_int32 >> 16);       // Parte alta (bits 31?16) 
....................     // peso_lo = (int16)(peso_int32 & 0xFFFF);    // Parte baja (bits 15?0) 
....................     //input_registers[0] = peso_hi; 
....................     // input_registers[1] = peso_lo; 
....................  
....................     //output_low(TX_ENABLE); 
....................  
....................  
....................     while (TRUE) { 
....................         if (data.AVAILABLE) { 
018B0:  MOVLB  1
018B2:  BTFSS  x71.0
018B4:  BRA    1908
....................             data.AVAILABLE = false; 
018B6:  BCF    x71.0
....................             procesar_trama(); 
018B8:  MOVLB  0
018BA:  GOTO   0D4E
....................             peso_int32 = f_PICtoIEEE(peso); 
018BE:  MOVFF  1AF,23
018C2:  MOVFF  1AE,22
018C6:  MOVFF  1AD,21
018CA:  MOVFF  1AC,20
018CE:  GOTO   0DF2
018D2:  MOVFF  03,1A7
018D6:  MOVFF  02,1A6
018DA:  MOVFF  01,1A5
018DE:  MOVFF  00,1A4
....................             peso_hi = (int16) (peso_int32 >> 16); // Parte alta (bits 31?16) 
018E2:  MOVFF  1A6,1A8
018E6:  MOVFF  1A7,1A9
018EA:  CLRF   03
....................             peso_lo = (int16) (peso_int32 & 0xFFFF); // Parte baja (bits 15?0) 
018EC:  MOVLB  1
018EE:  MOVFF  1A4,1AA
018F2:  MOVFF  1A5,1AB
018F6:  CLRF   03
....................             input_registers[0] = peso_hi; 
018F8:  MOVFF  1A9,17D
018FC:  MOVFF  1A8,17C
....................             input_registers[1] = peso_lo; 
01900:  MOVFF  1AB,17F
01904:  MOVFF  1AA,17E
....................         } 
....................         if (modbus_kbhit()) { 
01908:  MOVLB  0
0190A:  GOTO   0EF4
0190E:  MOVF   01,F
01910:  BZ    1914
....................             procesar_modbus(); 
01912:  BRA    12B6
....................  
....................         } 
01914:  BRA    18B0
....................     } 
.................... } 
01916:  SLEEP 

Configuration Fuses:
   Word  1: FFFA   HS RSTOSC_EXT NOCLKOUT CKS FCMEN
   Word  2: FFFD   MCLR PUT NOLPBOR BROWNOUT BORV24 ZCDDIS PPS1WAY STVREN NODEBUG NOXINST
   Word  3: FF9F   WDTSW NOWDT WDTWIN_SW WDTCLK_SW
   Word  4: DFFF   NOWRT NOWRTC NOWRTB NOWRTD SCANE NOLVP
   Word  5: FFFF   NOPROTECT NOCPD
   Word  6: FFFF   NOEBTR NOEBTRB
